{"version":3,"sources":["webpack://SoundFont/webpack/universalModuleDefinition","webpack://SoundFont/webpack/bootstrap","webpack://SoundFont/./src/riff.js","webpack://SoundFont/./src/sf2.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAA6B;AAC7B;AACA;AACA;AACO;AACP;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC,oDAAoD;;AAEpD,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,WAAW;;AAE9C;AACA,mCAAmC,WAAW;;AAE9C;AACA,mCAAmC,WAAW;AAC9C;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,WAAW;AAC1B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,4CAA4C;AAC5C;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,kDAAkD;AAClE;AACA,gBAAgB,kDAAkD;AAClE;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,kDAAkD;AAClE;AACA,gBAAgB,kDAAkD;AAClE;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC","file":"sf2.parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SoundFont\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SoundFont\"] = factory();\n\telse\n\t\troot[\"SoundFont\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/sf2.js\");\n","/**\n * Riff Parser class\n * @private\n */\nexport default class Riff {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n    this.length = optParams.length || input.length - this.ip;\n    /** @type {Array.<RiffChunk>} */\n    this.chunkList;\n    /** @type {number} */\n    this.offset = this.ip;\n    /** @type {boolean} */\n    this.padding =\n      optParams.padding !== void 0 ? optParams.padding : true;\n    /** @type {boolean} */\n    this.bigEndian =\n      optParams.bigEndian !== void 0 ? optParams.bigEndian : false;\n  }\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    const length = this.length + this.offset;\n\n    this.chunkList = [];\n\n    while (this.ip < length) {\n      this.parseChunk();\n    }\n  }\n\n  /**\n   */\n  parseChunk() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {number} */\n    let size;\n\n    this.chunkList.push(new RiffChunk(\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),\n      (size = this.bigEndian ?\n        ((input[ip++] << 24) | (input[ip++] << 16) |\n          (input[ip++] << 8) | (input[ip++])) >>> 0 :\n        ((input[ip++]) | (input[ip++] << 8) |\n          (input[ip++] << 16) | (input[ip++] << 24)) >>> 0\n      ),\n      ip\n    ));\n\n    ip += size;\n\n    // padding\n    if (this.padding && ((ip - this.offset) & 1) === 1) {\n      ip++;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @param {number} index chunk index.\n   * @return {?RiffChunk}\n   */\n  getChunk(index) {\n    /** @type {RiffChunk} */\n    const chunk = this.chunkList[index];\n\n    if (chunk === void 0) {\n      return null;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * @return {number}\n   */\n  getNumberOfChunks() {\n    return this.chunkList.length;\n  }\n}\n\n/**\n * Riff Chunk Structure\n * @interface\n */\nclass RiffChunk {\n  /**\n   * @param {string} type\n   * @param {number} size\n   * @param {number} offset\n   */\n  constructor(type, size, offset) {\n    /** @type {string} */\n    this.type = type;\n    /** @type {number} */\n    this.size = size;\n    /** @type {number} */\n    this.offset = offset;\n  }\n}\n","import Riff from './riff.js';\n/**\n * SoundFont Parser Class\n */\nexport class Parser {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {(Object|undefined)} */\n    this.parserOption = optParams.parserOption || {};\n    /** @type {(Number|undefined)} */\n    this.sampleRate = optParams.sampleRate || 22050; // よくわからんが、OSで指定されているサンプルレートを入れないと音が切れ切れになる。\n\n    /** @type {Array.<Object>} */\n    this.presetHeader;\n    /** @type {Array.<Object>} */\n    this.presetZone;\n    /** @type {Array.<Object>} */\n    this.presetZoneModulator;\n    /** @type {Array.<Object>} */\n    this.presetZoneGenerator;\n    /** @type {Array.<Object>} */\n    this.instrument;\n    /** @type {Array.<Object>} */\n    this.instrumentZone;\n    /** @type {Array.<Object>} */\n    this.instrumentZoneModulator;\n    /** @type {Array.<Object>} */\n    this.instrumentZoneGenerator;\n    /** @type {Array.<Object>} */\n    this.sampleHeader;\n\n    /**\n     * @type {Array.<string>}\n     * @const\n     */\n    this.GeneratorEnumeratorTable = [\n      'startAddrsOffset',\n      'endAddrsOffset',\n      'startloopAddrsOffset',\n      'endloopAddrsOffset',\n      'startAddrsCoarseOffset',\n      'modLfoToPitch',\n      'vibLfoToPitch',\n      'modEnvToPitch',\n      'initialFilterFc',\n      'initialFilterQ',\n      'modLfoToFilterFc',\n      'modEnvToFilterFc',\n      'endAddrsCoarseOffset',\n      'modLfoToVolume', , // 14\n      'chorusEffectsSend',\n      'reverbEffectsSend',\n      'pan', , , , // 18,19,20\n      'delayModLFO',\n      'freqModLFO',\n      'delayVibLFO',\n      'freqVibLFO',\n      'delayModEnv',\n      'attackModEnv',\n      'holdModEnv',\n      'decayModEnv',\n      'sustainModEnv',\n      'releaseModEnv',\n      'keynumToModEnvHold',\n      'keynumToModEnvDecay',\n      'delayVolEnv',\n      'attackVolEnv',\n      'holdVolEnv',\n      'decayVolEnv',\n      'sustainVolEnv',\n      'releaseVolEnv',\n      'keynumToVolEnvHold',\n      'keynumToVolEnvDecay',\n      'instrument', , // 42\n      'keyRange',\n      'velRange',\n      'startloopAddrsCoarseOffset',\n      'keynum',\n      'velocity',\n      'initialAttenuation', , // 49\n      'endloopAddrsCoarseOffset',\n      'coarseTune',\n      'fineTune',\n      'sampleID',\n      'sampleModes', , // 55\n      'scaleTuning',\n      'exclusiveClass',\n      'overridingRootKey', // 59\n      'endOper',\n    ];\n  }\n\n  /** @export */\n  parse() {\n    /** @type {Riff} */\n    const parser = new Riff(this.input, this.parserOption);\n\n    // parse RIFF chunk\n    parser.parse();\n    if (parser.chunkList.length !== 1) {\n      throw new Error('wrong chunk length');\n    }\n\n    /** @type {?RiffChunk} */\n    const chunk = parser.getChunk(0);\n    if (chunk === null) {\n      throw new Error('chunk not found');\n    }\n\n    this.parseRiffChunk(chunk);\n    // console.log(this.sampleHeader);\n    this.input = null;\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseRiffChunk(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'RIFF') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'sfbk') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n    if (parser.getNumberOfChunks() !== 3) {\n      throw new Error('invalid sfbk structure');\n    }\n\n    // INFO-list\n    this.parseInfoList( /** @type {!RiffChunk} */(parser.getChunk(0)));\n\n    // sdta-list\n    this.parseSdtaList( /** @type {!RiffChunk} */(parser.getChunk(1)));\n\n    // pdta-list\n    this.parsePdtaList( /** @type {!RiffChunk} */(parser.getChunk(2)));\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseInfoList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'INFO') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseSdtaList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'sdta') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n    if (parser.chunkList.length !== 1) {\n      throw new Error('TODO');\n    }\n    this.samplingData =\n      /** @type {{type: string, size: number, offset: number}} */\n      (parser.getChunk(0));\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePdtaList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'pdta') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n\n    // check number of chunks\n    if (parser.getNumberOfChunks() !== 9) {\n      throw new Error('invalid pdta chunk');\n    }\n\n    this.parsePhdr( /** @type {RiffChunk} */(parser.getChunk(0)));\n    this.parsePbag( /** @type {RiffChunk} */(parser.getChunk(1)));\n    this.parsePmod( /** @type {RiffChunk} */(parser.getChunk(2)));\n    this.parsePgen( /** @type {RiffChunk} */(parser.getChunk(3)));\n    this.parseInst( /** @type {RiffChunk} */(parser.getChunk(4)));\n    this.parseIbag( /** @type {RiffChunk} */(parser.getChunk(5)));\n    this.parseImod( /** @type {RiffChunk} */(parser.getChunk(6)));\n    this.parseIgen( /** @type {RiffChunk} */(parser.getChunk(7)));\n    this.parseShdr( /** @type {RiffChunk} */(parser.getChunk(8)));\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePhdr(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const presetHeader = this.presetHeader = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'phdr') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      presetHeader.push({\n        presetName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),\n        preset: data[ip++] | (data[ip++] << 8),\n        bank: data[ip++] | (data[ip++] << 8),\n        presetBagIndex: data[ip++] | (data[ip++] << 8),\n        library: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,\n        genre: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,\n        morphology: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePbag(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const presetZone = this.presetZone = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'pbag') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      presetZone.push({\n        presetGeneratorIndex: data[ip++] | (data[ip++] << 8),\n        presetModulatorIndex: data[ip++] | (data[ip++] << 8),\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePmod(chunk) {\n    // check parse target\n    if (chunk.type !== 'pmod') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.presetZoneModulator = this.parseModulator(chunk);\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePgen(chunk) {\n    // check parse target\n    if (chunk.type !== 'pgen') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n    this.presetZoneGenerator = this.parseGenerator(chunk);\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseInst(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const instrument = this.instrument = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'inst') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      instrument.push({\n        instrumentName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),\n        instrumentBagIndex: data[ip++] | (data[ip++] << 8),\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseIbag(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const instrumentZone = this.instrumentZone = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'ibag') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n\n    while (ip < size) {\n      instrumentZone.push({\n        instrumentGeneratorIndex: data[ip++] | (data[ip++] << 8),\n        instrumentModulatorIndex: data[ip++] | (data[ip++] << 8),\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseImod(chunk) {\n    // check parse target\n    if (chunk.type !== 'imod') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.instrumentZoneModulator = this.parseModulator(chunk);\n  };\n\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseIgen(chunk) {\n    // check parse target\n    if (chunk.type !== 'igen') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.instrumentZoneGenerator = this.parseGenerator(chunk);\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseShdr(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const samples = this.sample = [];\n    /** @type {Array.<Object>} */\n    const sampleHeader = this.sampleHeader = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n    /** @type {string} */\n    let sampleName;\n    /** @type {number} */\n    let start;\n    /** @type {number} */\n    let end;\n    /** @type {number} */\n    let startLoop;\n    /** @type {number} */\n    let endLoop;\n    /** @type {number} */\n    let sampleRate;\n    /** @type {number} */\n    let originalPitch;\n    /** @type {number} */\n    let pitchCorrection;\n    /** @type {number} */\n    let sampleLink;\n    /** @type {number} */\n    let sampleType;\n\n    // check parse target\n    if (chunk.type !== 'shdr') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      sampleName = String.fromCharCode.apply(null, data.subarray(ip, ip += 20));\n      start = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      end = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      startLoop = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      endLoop = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      sampleRate = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      originalPitch = data[ip++];\n      pitchCorrection = (data[ip++] << 24) >> 24;\n      sampleLink = data[ip++] | (data[ip++] << 8);\n      sampleType = data[ip++] | (data[ip++] << 8);\n\n      let sample = new Int16Array(new Uint8Array(data.subarray(\n        this.samplingData.offset + start * 2,\n        this.samplingData.offset + end * 2\n      )).buffer);\n\n      startLoop -= start;\n      endLoop -= start;\n\n      if (sampleRate > 0) {\n        const adjust = this.adjustSampleData(sample, sampleRate);\n        sample = adjust.sample;\n        sampleRate *= adjust.multiply;\n        startLoop *= adjust.multiply;\n        endLoop *= adjust.multiply;\n      }\n\n      samples.push(sample);\n\n      sampleHeader.push({\n        sampleName: sampleName,\n        start: start,\n        end: end,\n        startLoop: startLoop,\n        endLoop: endLoop,\n        sampleRate: sampleRate,\n        originalPitch: originalPitch,\n        pitchCorrection: pitchCorrection,\n        sampleLink: sampleLink,\n        sampleType: sampleType,\n      });\n    }\n  };\n\n  /**\n   * @param {Array} sample\n   * @param {number} sampleRate\n   * @return {object}\n   */\n  adjustSampleData(sample, sampleRate) {\n    /** @type {Int16Array} */\n    let newSample;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let multiply = 1;\n\n    // buffer\n    while (sampleRate < (this.sampleRate)) { // AudioContextのサンプルレートに変更\n      newSample = new Int16Array(sample.length * 2);\n      for (i = j = 0, il = sample.length; i < il; ++i) {\n        newSample[j++] = sample[i];\n        newSample[j++] = sample[i];\n      }\n      sample = newSample;\n      multiply *= 2;\n      sampleRate *= 2;\n    }\n\n    return {\n      sample: sample,\n      multiply: multiply,\n    };\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   * @return {Array.<Object>}\n   */\n  parseModulator(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n    /** @type {number} */\n    let code;\n    /** @type {string} */\n    let key;\n    /** @type {Array.<Object>} */\n    const output = [];\n\n    while (ip < size) {\n      // Src  Oper\n      // TODO\n      ip += 2;\n\n      // Dest Oper\n      code = data[ip++] | (data[ip++] << 8);\n      key = this.GeneratorEnumeratorTable[code];\n      if (key === void 0) {\n        // Amount\n        output.push({\n          type: key,\n          value: {\n            code: code,\n            amount: data[ip] | (data[ip + 1] << 8) << 16 >> 16,\n            lo: data[ip++],\n            hi: data[ip++],\n          },\n        });\n      } else {\n        // Amount\n        switch (key) {\n          case 'keyRange':\n          /* FALLTHROUGH */\n          case 'velRange':\n          /* FALLTHROUGH */\n          case 'keynum':\n          /* FALLTHROUGH */\n          case 'velocity':\n            output.push({\n              type: key,\n              value: {\n                lo: data[ip++],\n                hi: data[ip++],\n              },\n            });\n            break;\n          default:\n            output.push({\n              type: key,\n              value: {\n                amount: data[ip++] | (data[ip++] << 8) << 16 >> 16,\n              },\n            });\n            break;\n        }\n      }\n\n      // AmtSrcOper\n      // TODO\n      ip += 2;\n\n      // Trans Oper\n      // TODO\n      ip += 2;\n    }\n\n    return output;\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   * @return {Array.<Object>}\n   */\n  parseGenerator(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n    /** @type {number} */\n    let code;\n    /** @type {string} */\n    let key;\n    /** @type {Array.<Object>} */\n    const output = [];\n\n    while (ip < size) {\n      code = data[ip++] | (data[ip++] << 8);\n      key = this.GeneratorEnumeratorTable[code];\n      if (key === void 0) {\n        output.push({\n          type: key,\n          value: {\n            code: code,\n            amount: data[ip] | (data[ip + 1] << 8) << 16 >> 16,\n            lo: data[ip++],\n            hi: data[ip++],\n          },\n        });\n        continue;\n      }\n\n      switch (key) {\n        case 'keynum':\n        /* FALLTHROUGH */\n        case 'keyRange':\n        /* FALLTHROUGH */\n        case 'velRange':\n        /* FALLTHROUGH */\n        case 'velocity':\n          output.push({\n            type: key,\n            value: {\n              lo: data[ip++],\n              hi: data[ip++],\n            },\n          });\n          break;\n        default:\n          output.push({\n            type: key,\n            value: {\n              amount: data[ip++] | (data[ip++] << 8) << 16 >> 16,\n            },\n          });\n          break;\n      }\n    }\n\n    return output;\n  };\n\n  /**\n   * @return {Array.<object>}\n   */\n  createInstrument() {\n    /** @type {Array.<Object>} */\n    const instrument = this.instrument;\n    /** @type {Array.<Object>} */\n    const zone = this.instrumentZone;\n    /** @type {Array.<Object>} */\n    const output = [];\n    /** @type {number} */\n    let bagIndex;\n    /** @type {number} */\n    let bagIndexEnd;\n    /** @type {Array.<Object>} */\n    let zoneInfo;\n    /** @type {{generator: Object, generatorInfo: Array.<Object>}} */\n    let instrumentGenerator;\n    /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */\n    let instrumentModulator;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    // instrument -> instrument bag -> generator / modulator\n    for (i = 0, il = instrument.length; i < il; ++i) {\n      bagIndex = instrument[i].instrumentBagIndex;\n      bagIndexEnd = instrument[i + 1] ? instrument[i + 1].instrumentBagIndex : zone.length;\n      zoneInfo = [];\n\n      // instrument bag\n      for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {\n        instrumentGenerator = this.createInstrumentGenerator_(zone, j);\n        instrumentModulator = this.createInstrumentModulator_(zone, j);\n\n        zoneInfo.push({\n          generator: instrumentGenerator.generator,\n          generatorSequence: instrumentGenerator.generatorInfo,\n          modulator: instrumentModulator.modulator,\n          modulatorSequence: instrumentModulator.modulatorInfo,\n        });\n      }\n\n      output.push({\n        name: instrument[i].instrumentName,\n        info: zoneInfo,\n      });\n    }\n\n    return output;\n  };\n\n  /**\n   * @return {Array.<object>}\n   */\n  createPreset() {\n    /** @type {Array.<Object>} */\n    const preset = this.presetHeader;\n    /** @type {Array.<Object>} */\n    const zone = this.presetZone;\n    /** @type {Array.<Object>} */\n    const output = [];\n    /** @type {number} */\n    let bagIndex;\n    /** @type {number} */\n    let bagIndexEnd;\n    /** @type {Array.<Object>} */\n    let zoneInfo;\n    /** @type {number} */\n    let instrument;\n    /** @type {{generator: Object, generatorInfo: Array.<Object>}} */\n    let presetGenerator;\n    /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */\n    let presetModulator;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    // preset -> preset bag -> generator / modulator\n    for (i = 0, il = preset.length; i < il; ++i) {\n      bagIndex = preset[i].presetBagIndex;\n      bagIndexEnd = preset[i + 1] ? preset[i + 1].presetBagIndex : zone.length;\n      zoneInfo = [];\n\n      // preset bag\n      for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {\n        presetGenerator = this.createPresetGenerator_(zone, j);\n        presetModulator = this.createPresetModulator_(zone, j);\n\n        zoneInfo.push({\n          generator: presetGenerator.generator,\n          generatorSequence: presetGenerator.generatorInfo,\n          modulator: presetModulator.modulator,\n          modulatorSequence: presetModulator.modulatorInfo,\n        });\n\n        instrument =\n          presetGenerator.generator['instrument'] !== void 0 ?\n            presetGenerator.generator['instrument'].amount :\n            presetModulator.modulator['instrument'] !== void 0 ?\n              presetModulator.modulator['instrument'].amount :\n              null;\n      }\n\n      output.push({\n        name: preset[i].presetName,\n        info: zoneInfo,\n        header: preset[i],\n        instrument: instrument,\n      });\n    }\n\n    return output;\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{generator: Object, generatorInfo: Array.<Object>}}\n   * @private\n   */\n  createInstrumentGenerator_(zone, index) {\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].instrumentGeneratorIndex,\n      zone[index + 1] ? zone[index + 1].instrumentGeneratorIndex : this.instrumentZoneGenerator.length,\n      this.instrumentZoneGenerator\n    );\n\n    return {\n      generator: modgen.modgen,\n      generatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{modulator: Object, modulatorInfo: Array.<Object>}}\n   * @private\n   */\n  createInstrumentModulator_(zone, index) {\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].presetModulatorIndex,\n      zone[index + 1] ? zone[index + 1].instrumentModulatorIndex : this.instrumentZoneModulator.length,\n      this.instrumentZoneModulator\n    );\n\n    return {\n      modulator: modgen.modgen,\n      modulatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{generator: Object, generatorInfo: Array.<Object>}}\n   * @private\n   */\n  createPresetGenerator_(zone, index) {\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].presetGeneratorIndex,\n      zone[index + 1] ? zone[index + 1].presetGeneratorIndex : this.presetZoneGenerator.length,\n      this.presetZoneGenerator\n    );\n\n    return {\n      generator: modgen.modgen,\n      generatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{modulator: Object, modulatorInfo: Array.<Object>}}\n   * @private\n   */\n  createPresetModulator_(zone, index) {\n    /** @type {{modgen: Object, modgenInfo: Array.<Object>}} */\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].presetModulatorIndex,\n      zone[index + 1] ? zone[index + 1].presetModulatorIndex : this.presetZoneModulator.length,\n      this.presetZoneModulator\n    );\n\n    return {\n      modulator: modgen.modgen,\n      modulatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} indexStart\n   * @param {number} indexEnd\n   * @param {Array} zoneModGen\n   * @return {{modgen: Object, modgenInfo: Array.<Object>}}\n   * @private\n   */\n  createBagModGen_(zone, indexStart, indexEnd, zoneModGen) {\n    /** @type {Array.<Object>} */\n    const modgenInfo = [];\n    /** @type {Object} */\n    const modgen = {\n      'unknown': [],\n      'keyRange': {\n        hi: 127,\n        lo: 0,\n      },\n    }; // TODO\n    /** @type {Object} */\n    let info;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n\n    for (i = indexStart, il = indexEnd; i < il; ++i) {\n      info = zoneModGen[i];\n      modgenInfo.push(info);\n\n      if (info.type === 'unknown') {\n        modgen.unknown.push(info.value);\n      } else {\n        modgen[info.type] = info.value;\n      }\n    }\n\n    return {\n      modgen: modgen,\n      modgenInfo: modgenInfo,\n    };\n  }\n}\n\nexport default Parser;\n"],"sourceRoot":""}