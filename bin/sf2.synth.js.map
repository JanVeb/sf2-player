{"version":3,"sources":["webpack://SoundFont/webpack/universalModuleDefinition","webpack://SoundFont/webpack/bootstrap","webpack://SoundFont/./node_modules/@logue/reverb/src/reverb.js","webpack://SoundFont/./src/riff.js","webpack://SoundFont/./src/sf2.js","webpack://SoundFont/./src/sound_font_synth.js","webpack://SoundFont/./src/sound_font_synth_note.js","webpack://SoundFont/./src/wml.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf;AACe;AACf;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+BAA+B;AAC/B,eAAe,aAAa;AAC5B;AACA,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,iBAAiB;AAChC;;AAEA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,sBAAsB;AACrC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,8BAA8B;AAC7C;AACA,eAAe,8BAA8B;AAC7C;;AAEA,mBAAmB,YAAY;AAC/B,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7MA;AAAA;AAAA;AACA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAA6B;AAC7B;AACA;AACA;AACO;AACP;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA,mCAAmC;AACnC,eAAe,UAAU;AACzB;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC,oDAAoD;;AAEpD,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,WAAW;;AAE9C;AACA,mCAAmC,WAAW;;AAE9C;AACA,mCAAmC,WAAW;AAC9C;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,uBAAuB,gDAAI,QAAQ,wCAAwC;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC,+BAA+B,UAAU;AACzC;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,eAAe,WAAW;AAC1B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,4CAA4C;AAC5C;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,kDAAkD;AAClE;AACA,gBAAgB,kDAAkD;AAClE;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,kDAAkD;AAClE;AACA,gBAAgB,kDAAkD;AAClE;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;;AC56BtB;AAAA;AAAA;AAAA;AAAA;AAAsD;AAC3B;AACmB;AAC9C;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,WAAW;AACxB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,WAAW;AAC1B;AACA,eAAe,iBAAiB;AAChC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,aAAa;AAC5B;AACA,eAAe,SAAS;AACxB;AACA,eAAe,sBAAsB;AACrC;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;;AAEA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;;AAEA,eAAe,uBAAuB;AACtC;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;;AAEA,eAAe,OAAO;AACtB,sBAAsB,gEAAM;AAC5B;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,aAAa;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;;AAEA,sBAAsB,4CAAM;AAC5B;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,sBAAsB,4CAAM;AAC5B;AACA;;AAEA,eAAe,uBAAuB;AACtC;AACA,eAAe,iBAAiB;AAChC;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;;AAGA,yEAAyE,SAAS;AAClF;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,eAAe,SAAS;AACxB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,yBAAyB,cAAc;AACvC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,cAAc;AACd,qBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C,2BAA2B,oBAAoB;AAC/C;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,YAAY;AAC3B;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gBAAgB;AAC/B,qBAAqB,8DAAe;AACpC;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,wBAAwB;AACvC;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,QAAQ;AACvB;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,wBAAwB;AACvC;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,kCAAkC;AACjD;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,eAAe,gBAAgB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,KAAK;AACL,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEe,0EAAW,EAAC;;;;;;;;;;;;;AC/pC3B;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,aAAa;AAC1B,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,aAAa;AAC5B;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,WAAW;AAC1B;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA,eAAe,YAAY;AAC3B;AACA,eAAe,sBAAsB;AACrC;AACA,eAAe,iBAAiB;AAChC;AACA,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB;AACA,eAAe,iBAAiB;AAChC;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,6DAA6D;AAC7D,eAAe,OAAO;AACtB,6DAA6D;;AAE7D;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,oEAAoE;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,sBAAsB;AACrC;AACA,eAAe,SAAS;AACxB;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,8EAAe,EAAC;;;;;;;;;;;;;ACpa/B;AAAA;AAAA;AAA6C;;AAE7C;AACA;AACA;AACO;AACP;AACA,aAAa,OAAO;AACpB;AACA,yBAAyB;AACzB,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,sBAAsB;AACrC,+BAA+B;AAC/B,eAAe,SAAS;AACxB;AACA,eAAe,eAAe;AAC9B;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,eAAe;AAC9B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,eAAe,WAAW;AAC1B;;AAEA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA,eAAe,YAAY;AAC3B;AACA,eAAe,OAAO;AACtB;;AAEA;AACA,+BAA+B,yDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,YAAY;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,0EAAW,EAAC","file":"sf2.synth.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SoundFont\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SoundFont\"] = factory();\n\telse\n\t\troot[\"SoundFont\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/wml.js\");\n","/**\n * JS reverb effect class\n *\n * @author    Logue\n * @copyright 2019 Logue <logue@hotmail.co.jp>\n * @license   MIT\n * @see       {@link https://github.com/logue/Reverb.js}\n *            {@link https://github.com/web-audio-components/simple-reverb}\n */\nexport default class Reverb {\n  /**\n   * constructor\n   * @param {AudioContext} ctx\n   * @param {{\n   *   freq: (number|undefined),\n   *   decay: (number|undefined),\n   *   delay: (number|undefined),\n   *   filterType: (string|undefined),\n   *   mix: (number|undefined),\n   *   reverse: (boolean|undefined),\n   *   time: (number|undefined)\n   * }} options\n   */\n  constructor(ctx, options = {}) {\n    /** @type {AudioContext} */\n    this.ctx = ctx;\n    /** @type {GainNode} */\n    this.wetGainNode = this.ctx.createGain();\n    /** @type {GainNode} */\n    this.dryGainNode = this.ctx.createGain();\n    /** @type {ConvolverNode} */\n    this.node = this.ctx.createConvolver();\n    /** @type {BiquadFilterNode} */\n    this.filterNode = this.ctx.createBiquadFilter();\n\n    // デフォルト値\n    /** @type {number} */\n    this._freq = options.freq || 440;\n    /** @type {number} */\n    this._decay = options.decay || 1;\n    /** @type {number} */\n    this._delay = options.delay || 0.5;\n    /** @type {BiquadFilterNode|null} */\n    this._filterType = options.filterType || 'bandpass';\n    /** @type {number} */\n    this._mix = options.mix || 0.5;\n    /** @type {boolean} */\n    this._reverse = options.reverse || false;\n    /** @type {number} */\n    this._time = options.time || 1;\n\n    // エフェクタに反映\n    this.mix(this._mix);\n    this.filterType(this._filterType);\n    this.freq(this._freq);\n    // インパルス応答を生成\n    this.buildImpulse();\n\n    // エフェクトのかかり方の接続\n    this.node.connect(this.dryGainNode);\n    this.node.connect(this.wetGainNode);\n    // エフェクトを接続\n    this.node.connect(this.filterNode);\n    this.dryGainNode.connect(this.node);\n    this.wetGainNode.connect(this.node);\n    // フィルタを接続\n    this.filterNode.connect(this.node);\n  };\n\n  /** @param {number} mix */\n  mix(mix) {\n    this._mix = mix;\n    this.dryGainNode.gain.setTargetAtTime(this.getDryLevel(mix) / 127, this.ctx.currentTime, 0.015);\n    this.wetGainNode.gain.setTargetAtTime(this.getWetLevel(mix) / 127, this.ctx.currentTime, 0.015);\n  }\n\n  /** @param {number} time */\n  time(time) {\n    this._time = time;\n    this.buildImpulse();\n  }\n\n  /**\n   * Impulse response decay rate.\n   * @param {number} decay\n   */\n  decay(decay) {\n    this._decay = decay;\n    this.buildImpulse();\n  }\n\n  /**\n   * Impulse response delay rate.\n   * @param {number} delay\n   */\n  delay(delay) {\n    this._delay = delay;\n    this.buildImpulse();\n  }\n\n  /**\n   * Reverse the impulse response.\n   * @param {boolean} reverse\n   */\n  reverse(reverse) {\n    this._reverse = reverse;\n    this.buildImpulse();\n  }\n\n  /**\n   * Frequency.\n   * @param {number} freq\n   */\n  freq(freq) {\n    this._freq = freq;\n    this.filterNode.frequency.setTargetAtTime(this._freq, this.ctx.currentTime, 0.015);\n  }\n\n  /**\n   * Filter Type.\n   * @param {BiquadFilterNode|null} type\n   */\n  filterType(type) {\n    this.filterNode.type = this._filterType = type;\n  }\n\n  /**\n   * Utility function for building an impulse response\n   * from the module parameters.\n   * @private\n   */\n  buildImpulse() {\n    /** @type {number} */\n    const rate = this.ctx.sampleRate;\n    /** @type {number} */\n    const length = Math.max(rate * this._time, 1);\n    /** @type {number} */\n    const delayDuration = rate * this._delay;\n    /** @type {AudioBuffer} */\n    const impulse = this.ctx.createBuffer(2, length, rate);\n    /** @type {Array<number>|ArrayBufferView} */\n    const impulseL = new Float32Array(length);\n    /** @type {Array<number>|ArrayBufferView} */\n    const impulseR = new Float32Array(length);\n\n    for (let i = 0; i < length; i++) {\n      /** @var {number} */\n      let n = 0;\n      /** @var {number} */\n      let pow = 0;\n      if (i < delayDuration) {\n        // Delay Effect\n        impulseL[i] = 0;\n        impulseR[i] = 0;\n        n = this._reverse ? length - (i - delayDuration) : i - delayDuration;\n      } else {\n        n = this._reverse ? length - i : i;\n      }\n      pow = Math.pow(1 - n / length, this._decay);\n      impulseL[i] = (Math.random() * 2 - 1) * pow;\n      impulseR[i] = (Math.random() * 2 - 1) * pow;\n    }\n\n    // Generate stereo inpulse response data.\n    impulse.getChannelData(0).set(impulseL);\n    impulse.getChannelData(1).set(impulseR);\n\n    this.node.buffer = impulse;\n  }\n\n  /**\n   * Set Dry level.\n   * @param {number} value\n   * @return {number}\n   * @private\n   */\n  getDryLevel(value) {\n    if (value > 1 || value < 0) {\n      return 0;\n    }\n\n    if (value <= 0.5) {\n      return 1;\n    }\n\n    return 1 - ((value - 0.5) * 2);\n  }\n\n  /**\n   * Set Wet level.\n   * @param {number} value\n   * @return {number}\n   * @private\n   */\n  getWetLevel(value) {\n    if (value > 1 || value < 0) {\n      return 0;\n    }\n\n    if (value >= 0.5) {\n      return 1;\n    }\n\n    return 1 - ((value - 0.5) * 2);\n  }\n};\n","/**\n * Riff Parser class\n * @private\n */\nexport default class Riff {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n    this.length = optParams.length || input.length - this.ip;\n    /** @type {Array.<RiffChunk>} */\n    this.chunkList;\n    /** @type {number} */\n    this.offset = this.ip;\n    /** @type {boolean} */\n    this.padding =\n      optParams.padding !== void 0 ? optParams.padding : true;\n    /** @type {boolean} */\n    this.bigEndian =\n      optParams.bigEndian !== void 0 ? optParams.bigEndian : false;\n  }\n\n  /**\n   */\n  parse() {\n    /** @type {number} */\n    const length = this.length + this.offset;\n\n    this.chunkList = [];\n\n    while (this.ip < length) {\n      this.parseChunk();\n    }\n  }\n\n  /**\n   */\n  parseChunk() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n    let ip = this.ip;\n    /** @type {number} */\n    let size;\n\n    this.chunkList.push(new RiffChunk(\n      String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),\n      (size = this.bigEndian ?\n        ((input[ip++] << 24) | (input[ip++] << 16) |\n          (input[ip++] << 8) | (input[ip++])) >>> 0 :\n        ((input[ip++]) | (input[ip++] << 8) |\n          (input[ip++] << 16) | (input[ip++] << 24)) >>> 0\n      ),\n      ip\n    ));\n\n    ip += size;\n\n    // padding\n    if (this.padding && ((ip - this.offset) & 1) === 1) {\n      ip++;\n    }\n\n    this.ip = ip;\n  }\n\n  /**\n   * @param {number} index chunk index.\n   * @return {?RiffChunk}\n   */\n  getChunk(index) {\n    /** @type {RiffChunk} */\n    const chunk = this.chunkList[index];\n\n    if (chunk === void 0) {\n      return null;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * @return {number}\n   */\n  getNumberOfChunks() {\n    return this.chunkList.length;\n  }\n}\n\n/**\n * Riff Chunk Structure\n * @interface\n */\nclass RiffChunk {\n  /**\n   * @param {string} type\n   * @param {number} size\n   * @param {number} offset\n   */\n  constructor(type, size, offset) {\n    /** @type {string} */\n    this.type = type;\n    /** @type {number} */\n    this.size = size;\n    /** @type {number} */\n    this.offset = offset;\n  }\n}\n","import Riff from './riff.js';\n/**\n * SoundFont Parser Class\n */\nexport class Parser {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {(Object|undefined)} */\n    this.parserOption = optParams.parserOption || {};\n    /** @type {(Number|undefined)} */\n    this.sampleRate = optParams.sampleRate || 22050; // よくわからんが、OSで指定されているサンプルレートを入れないと音が切れ切れになる。\n\n    /** @type {Array.<Object>} */\n    this.presetHeader;\n    /** @type {Array.<Object>} */\n    this.presetZone;\n    /** @type {Array.<Object>} */\n    this.presetZoneModulator;\n    /** @type {Array.<Object>} */\n    this.presetZoneGenerator;\n    /** @type {Array.<Object>} */\n    this.instrument;\n    /** @type {Array.<Object>} */\n    this.instrumentZone;\n    /** @type {Array.<Object>} */\n    this.instrumentZoneModulator;\n    /** @type {Array.<Object>} */\n    this.instrumentZoneGenerator;\n    /** @type {Array.<Object>} */\n    this.sampleHeader;\n\n    /**\n     * @type {Array.<string>}\n     * @const\n     */\n    this.GeneratorEnumeratorTable = [\n      'startAddrsOffset',\n      'endAddrsOffset',\n      'startloopAddrsOffset',\n      'endloopAddrsOffset',\n      'startAddrsCoarseOffset',\n      'modLfoToPitch',\n      'vibLfoToPitch',\n      'modEnvToPitch',\n      'initialFilterFc',\n      'initialFilterQ',\n      'modLfoToFilterFc',\n      'modEnvToFilterFc',\n      'endAddrsCoarseOffset',\n      'modLfoToVolume', , // 14\n      'chorusEffectsSend',\n      'reverbEffectsSend',\n      'pan', , , , // 18,19,20\n      'delayModLFO',\n      'freqModLFO',\n      'delayVibLFO',\n      'freqVibLFO',\n      'delayModEnv',\n      'attackModEnv',\n      'holdModEnv',\n      'decayModEnv',\n      'sustainModEnv',\n      'releaseModEnv',\n      'keynumToModEnvHold',\n      'keynumToModEnvDecay',\n      'delayVolEnv',\n      'attackVolEnv',\n      'holdVolEnv',\n      'decayVolEnv',\n      'sustainVolEnv',\n      'releaseVolEnv',\n      'keynumToVolEnvHold',\n      'keynumToVolEnvDecay',\n      'instrument', , // 42\n      'keyRange',\n      'velRange',\n      'startloopAddrsCoarseOffset',\n      'keynum',\n      'velocity',\n      'initialAttenuation', , // 49\n      'endloopAddrsCoarseOffset',\n      'coarseTune',\n      'fineTune',\n      'sampleID',\n      'sampleModes', , // 55\n      'scaleTuning',\n      'exclusiveClass',\n      'overridingRootKey', // 59\n      'endOper',\n    ];\n  }\n\n  /** @export */\n  parse() {\n    /** @type {Riff} */\n    const parser = new Riff(this.input, this.parserOption);\n\n    // parse RIFF chunk\n    parser.parse();\n    if (parser.chunkList.length !== 1) {\n      throw new Error('wrong chunk length');\n    }\n\n    /** @type {?RiffChunk} */\n    const chunk = parser.getChunk(0);\n    if (chunk === null) {\n      throw new Error('chunk not found');\n    }\n\n    this.parseRiffChunk(chunk);\n    // console.log(this.sampleHeader);\n    this.input = null;\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseRiffChunk(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'RIFF') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'sfbk') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n    if (parser.getNumberOfChunks() !== 3) {\n      throw new Error('invalid sfbk structure');\n    }\n\n    // INFO-list\n    this.parseInfoList( /** @type {!RiffChunk} */(parser.getChunk(0)));\n\n    // sdta-list\n    this.parseSdtaList( /** @type {!RiffChunk} */(parser.getChunk(1)));\n\n    // pdta-list\n    this.parsePdtaList( /** @type {!RiffChunk} */(parser.getChunk(2)));\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseInfoList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'INFO') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseSdtaList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'sdta') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n    if (parser.chunkList.length !== 1) {\n      throw new Error('TODO');\n    }\n    this.samplingData =\n      /** @type {{type: string, size: number, offset: number}} */\n      (parser.getChunk(0));\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePdtaList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n\n    // check parse target\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    // check signature\n    /** @type {string} */\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n    if (signature !== 'pdta') {\n      throw new Error('invalid signature:' + signature);\n    }\n\n    // read structure\n    /** @type {Riff} */\n    const parser = new Riff(data, { 'index': ip, 'length': chunk.size - 4 });\n    parser.parse();\n\n    // check number of chunks\n    if (parser.getNumberOfChunks() !== 9) {\n      throw new Error('invalid pdta chunk');\n    }\n\n    this.parsePhdr( /** @type {RiffChunk} */(parser.getChunk(0)));\n    this.parsePbag( /** @type {RiffChunk} */(parser.getChunk(1)));\n    this.parsePmod( /** @type {RiffChunk} */(parser.getChunk(2)));\n    this.parsePgen( /** @type {RiffChunk} */(parser.getChunk(3)));\n    this.parseInst( /** @type {RiffChunk} */(parser.getChunk(4)));\n    this.parseIbag( /** @type {RiffChunk} */(parser.getChunk(5)));\n    this.parseImod( /** @type {RiffChunk} */(parser.getChunk(6)));\n    this.parseIgen( /** @type {RiffChunk} */(parser.getChunk(7)));\n    this.parseShdr( /** @type {RiffChunk} */(parser.getChunk(8)));\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePhdr(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const presetHeader = this.presetHeader = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'phdr') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      presetHeader.push({\n        presetName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),\n        preset: data[ip++] | (data[ip++] << 8),\n        bank: data[ip++] | (data[ip++] << 8),\n        presetBagIndex: data[ip++] | (data[ip++] << 8),\n        library: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,\n        genre: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,\n        morphology: (data[ip++] | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)) >>> 0,\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePbag(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const presetZone = this.presetZone = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'pbag') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      presetZone.push({\n        presetGeneratorIndex: data[ip++] | (data[ip++] << 8),\n        presetModulatorIndex: data[ip++] | (data[ip++] << 8),\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePmod(chunk) {\n    // check parse target\n    if (chunk.type !== 'pmod') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.presetZoneModulator = this.parseModulator(chunk);\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePgen(chunk) {\n    // check parse target\n    if (chunk.type !== 'pgen') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n    this.presetZoneGenerator = this.parseGenerator(chunk);\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseInst(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const instrument = this.instrument = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'inst') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      instrument.push({\n        instrumentName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),\n        instrumentBagIndex: data[ip++] | (data[ip++] << 8),\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseIbag(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const instrumentZone = this.instrumentZone = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n\n    // check parse target\n    if (chunk.type !== 'ibag') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n\n    while (ip < size) {\n      instrumentZone.push({\n        instrumentGeneratorIndex: data[ip++] | (data[ip++] << 8),\n        instrumentModulatorIndex: data[ip++] | (data[ip++] << 8),\n      });\n    }\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseImod(chunk) {\n    // check parse target\n    if (chunk.type !== 'imod') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.instrumentZoneModulator = this.parseModulator(chunk);\n  };\n\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseIgen(chunk) {\n    // check parse target\n    if (chunk.type !== 'igen') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.instrumentZoneGenerator = this.parseGenerator(chunk);\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseShdr(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n    const samples = this.sample = [];\n    /** @type {Array.<Object>} */\n    const sampleHeader = this.sampleHeader = [];\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n    /** @type {string} */\n    let sampleName;\n    /** @type {number} */\n    let start;\n    /** @type {number} */\n    let end;\n    /** @type {number} */\n    let startLoop;\n    /** @type {number} */\n    let endLoop;\n    /** @type {number} */\n    let sampleRate;\n    /** @type {number} */\n    let originalPitch;\n    /** @type {number} */\n    let pitchCorrection;\n    /** @type {number} */\n    let sampleLink;\n    /** @type {number} */\n    let sampleType;\n\n    // check parse target\n    if (chunk.type !== 'shdr') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      sampleName = String.fromCharCode.apply(null, data.subarray(ip, ip += 20));\n      start = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      end = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      startLoop = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      endLoop = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      sampleRate = (\n        (data[ip++] << 0) | (data[ip++] << 8) | (data[ip++] << 16) | (data[ip++] << 24)\n      ) >>> 0;\n      originalPitch = data[ip++];\n      pitchCorrection = (data[ip++] << 24) >> 24;\n      sampleLink = data[ip++] | (data[ip++] << 8);\n      sampleType = data[ip++] | (data[ip++] << 8);\n\n      let sample = new Int16Array(new Uint8Array(data.subarray(\n        this.samplingData.offset + start * 2,\n        this.samplingData.offset + end * 2\n      )).buffer);\n\n      startLoop -= start;\n      endLoop -= start;\n\n      if (sampleRate > 0) {\n        const adjust = this.adjustSampleData(sample, sampleRate);\n        sample = adjust.sample;\n        sampleRate *= adjust.multiply;\n        startLoop *= adjust.multiply;\n        endLoop *= adjust.multiply;\n      }\n\n      samples.push(sample);\n\n      sampleHeader.push({\n        sampleName: sampleName,\n        start: start,\n        end: end,\n        startLoop: startLoop,\n        endLoop: endLoop,\n        sampleRate: sampleRate,\n        originalPitch: originalPitch,\n        pitchCorrection: pitchCorrection,\n        sampleLink: sampleLink,\n        sampleType: sampleType,\n      });\n    }\n  };\n\n  /**\n   * @param {Array} sample\n   * @param {number} sampleRate\n   * @return {object}\n   */\n  adjustSampleData(sample, sampleRate) {\n    /** @type {Int16Array} */\n    let newSample;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let multiply = 1;\n\n    // buffer\n    while (sampleRate < (this.sampleRate)) { // AudioContextのサンプルレートに変更\n      newSample = new Int16Array(sample.length * 2);\n      for (i = j = 0, il = sample.length; i < il; ++i) {\n        newSample[j++] = sample[i];\n        newSample[j++] = sample[i];\n      }\n      sample = newSample;\n      multiply *= 2;\n      sampleRate *= 2;\n    }\n\n    return {\n      sample: sample,\n      multiply: multiply,\n    };\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   * @return {Array.<Object>}\n   */\n  parseModulator(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n    /** @type {number} */\n    let code;\n    /** @type {string} */\n    let key;\n    /** @type {Array.<Object>} */\n    const output = [];\n\n    while (ip < size) {\n      // Src  Oper\n      // TODO\n      ip += 2;\n\n      // Dest Oper\n      code = data[ip++] | (data[ip++] << 8);\n      key = this.GeneratorEnumeratorTable[code];\n      if (key === void 0) {\n        // Amount\n        output.push({\n          type: key,\n          value: {\n            code: code,\n            amount: data[ip] | (data[ip + 1] << 8) << 16 >> 16,\n            lo: data[ip++],\n            hi: data[ip++],\n          },\n        });\n      } else {\n        // Amount\n        switch (key) {\n          case 'keyRange':\n          /* FALLTHROUGH */\n          case 'velRange':\n          /* FALLTHROUGH */\n          case 'keynum':\n          /* FALLTHROUGH */\n          case 'velocity':\n            output.push({\n              type: key,\n              value: {\n                lo: data[ip++],\n                hi: data[ip++],\n              },\n            });\n            break;\n          default:\n            output.push({\n              type: key,\n              value: {\n                amount: data[ip++] | (data[ip++] << 8) << 16 >> 16,\n              },\n            });\n            break;\n        }\n      }\n\n      // AmtSrcOper\n      // TODO\n      ip += 2;\n\n      // Trans Oper\n      // TODO\n      ip += 2;\n    }\n\n    return output;\n  };\n\n  /**\n   * @param {RiffChunk} chunk\n   * @return {Array.<Object>}\n   */\n  parseGenerator(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n    let ip = chunk.offset;\n    /** @type {number} */\n    const size = chunk.offset + chunk.size;\n    /** @type {number} */\n    let code;\n    /** @type {string} */\n    let key;\n    /** @type {Array.<Object>} */\n    const output = [];\n\n    while (ip < size) {\n      code = data[ip++] | (data[ip++] << 8);\n      key = this.GeneratorEnumeratorTable[code];\n      if (key === void 0) {\n        output.push({\n          type: key,\n          value: {\n            code: code,\n            amount: data[ip] | (data[ip + 1] << 8) << 16 >> 16,\n            lo: data[ip++],\n            hi: data[ip++],\n          },\n        });\n        continue;\n      }\n\n      switch (key) {\n        case 'keynum':\n        /* FALLTHROUGH */\n        case 'keyRange':\n        /* FALLTHROUGH */\n        case 'velRange':\n        /* FALLTHROUGH */\n        case 'velocity':\n          output.push({\n            type: key,\n            value: {\n              lo: data[ip++],\n              hi: data[ip++],\n            },\n          });\n          break;\n        default:\n          output.push({\n            type: key,\n            value: {\n              amount: data[ip++] | (data[ip++] << 8) << 16 >> 16,\n            },\n          });\n          break;\n      }\n    }\n\n    return output;\n  };\n\n  /**\n   * @return {Array.<object>}\n   */\n  createInstrument() {\n    /** @type {Array.<Object>} */\n    const instrument = this.instrument;\n    /** @type {Array.<Object>} */\n    const zone = this.instrumentZone;\n    /** @type {Array.<Object>} */\n    const output = [];\n    /** @type {number} */\n    let bagIndex;\n    /** @type {number} */\n    let bagIndexEnd;\n    /** @type {Array.<Object>} */\n    let zoneInfo;\n    /** @type {{generator: Object, generatorInfo: Array.<Object>}} */\n    let instrumentGenerator;\n    /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */\n    let instrumentModulator;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    // instrument -> instrument bag -> generator / modulator\n    for (i = 0, il = instrument.length; i < il; ++i) {\n      bagIndex = instrument[i].instrumentBagIndex;\n      bagIndexEnd = instrument[i + 1] ? instrument[i + 1].instrumentBagIndex : zone.length;\n      zoneInfo = [];\n\n      // instrument bag\n      for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {\n        instrumentGenerator = this.createInstrumentGenerator_(zone, j);\n        instrumentModulator = this.createInstrumentModulator_(zone, j);\n\n        zoneInfo.push({\n          generator: instrumentGenerator.generator,\n          generatorSequence: instrumentGenerator.generatorInfo,\n          modulator: instrumentModulator.modulator,\n          modulatorSequence: instrumentModulator.modulatorInfo,\n        });\n      }\n\n      output.push({\n        name: instrument[i].instrumentName,\n        info: zoneInfo,\n      });\n    }\n\n    return output;\n  };\n\n  /**\n   * @return {Array.<object>}\n   */\n  createPreset() {\n    /** @type {Array.<Object>} */\n    const preset = this.presetHeader;\n    /** @type {Array.<Object>} */\n    const zone = this.presetZone;\n    /** @type {Array.<Object>} */\n    const output = [];\n    /** @type {number} */\n    let bagIndex;\n    /** @type {number} */\n    let bagIndexEnd;\n    /** @type {Array.<Object>} */\n    let zoneInfo;\n    /** @type {number} */\n    let instrument;\n    /** @type {{generator: Object, generatorInfo: Array.<Object>}} */\n    let presetGenerator;\n    /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */\n    let presetModulator;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n\n    // preset -> preset bag -> generator / modulator\n    for (i = 0, il = preset.length; i < il; ++i) {\n      bagIndex = preset[i].presetBagIndex;\n      bagIndexEnd = preset[i + 1] ? preset[i + 1].presetBagIndex : zone.length;\n      zoneInfo = [];\n\n      // preset bag\n      for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {\n        presetGenerator = this.createPresetGenerator_(zone, j);\n        presetModulator = this.createPresetModulator_(zone, j);\n\n        zoneInfo.push({\n          generator: presetGenerator.generator,\n          generatorSequence: presetGenerator.generatorInfo,\n          modulator: presetModulator.modulator,\n          modulatorSequence: presetModulator.modulatorInfo,\n        });\n\n        instrument =\n          presetGenerator.generator['instrument'] !== void 0 ?\n            presetGenerator.generator['instrument'].amount :\n            presetModulator.modulator['instrument'] !== void 0 ?\n              presetModulator.modulator['instrument'].amount :\n              null;\n      }\n\n      output.push({\n        name: preset[i].presetName,\n        info: zoneInfo,\n        header: preset[i],\n        instrument: instrument,\n      });\n    }\n\n    return output;\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{generator: Object, generatorInfo: Array.<Object>}}\n   * @private\n   */\n  createInstrumentGenerator_(zone, index) {\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].instrumentGeneratorIndex,\n      zone[index + 1] ? zone[index + 1].instrumentGeneratorIndex : this.instrumentZoneGenerator.length,\n      this.instrumentZoneGenerator\n    );\n\n    return {\n      generator: modgen.modgen,\n      generatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{modulator: Object, modulatorInfo: Array.<Object>}}\n   * @private\n   */\n  createInstrumentModulator_(zone, index) {\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].presetModulatorIndex,\n      zone[index + 1] ? zone[index + 1].instrumentModulatorIndex : this.instrumentZoneModulator.length,\n      this.instrumentZoneModulator\n    );\n\n    return {\n      modulator: modgen.modgen,\n      modulatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{generator: Object, generatorInfo: Array.<Object>}}\n   * @private\n   */\n  createPresetGenerator_(zone, index) {\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].presetGeneratorIndex,\n      zone[index + 1] ? zone[index + 1].presetGeneratorIndex : this.presetZoneGenerator.length,\n      this.presetZoneGenerator\n    );\n\n    return {\n      generator: modgen.modgen,\n      generatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{modulator: Object, modulatorInfo: Array.<Object>}}\n   * @private\n   */\n  createPresetModulator_(zone, index) {\n    /** @type {{modgen: Object, modgenInfo: Array.<Object>}} */\n    const modgen = this.createBagModGen_(\n      zone,\n      zone[index].presetModulatorIndex,\n      zone[index + 1] ? zone[index + 1].presetModulatorIndex : this.presetZoneModulator.length,\n      this.presetZoneModulator\n    );\n\n    return {\n      modulator: modgen.modgen,\n      modulatorInfo: modgen.modgenInfo,\n    };\n  };\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} indexStart\n   * @param {number} indexEnd\n   * @param {Array} zoneModGen\n   * @return {{modgen: Object, modgenInfo: Array.<Object>}}\n   * @private\n   */\n  createBagModGen_(zone, indexStart, indexEnd, zoneModGen) {\n    /** @type {Array.<Object>} */\n    const modgenInfo = [];\n    /** @type {Object} */\n    const modgen = {\n      'unknown': [],\n      'keyRange': {\n        hi: 127,\n        lo: 0,\n      },\n    }; // TODO\n    /** @type {Object} */\n    let info;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n\n    for (i = indexStart, il = indexEnd; i < il; ++i) {\n      info = zoneModGen[i];\n      modgenInfo.push(info);\n\n      if (info.type === 'unknown') {\n        modgen.unknown.push(info.value);\n      } else {\n        modgen[info.type] = info.value;\n      }\n    }\n\n    return {\n      modgen: modgen,\n      modgenInfo: modgenInfo,\n    };\n  }\n}\n\nexport default Parser;\n","import SynthesizerNote from './sound_font_synth_note';\nimport Parser from './sf2';\nimport Reverb from '@logue/reverb/src/reverb';\n/**\n * Synthesizer Class\n * @private\n */\nexport class Synthesizer {\n  /**\n   * @param {Uint8Array} input\n   */\n  constructor(input) {\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n\n    /** @type {Uint8Array} */\n    this.input = input;\n    /** @type {SoundFont.Parser} */\n    this.parser = {};\n    /** @type {number} */\n    this.bank = 0;\n    /** @type {Array.<Array.<Object>>} */\n    this.bankSet = {};\n    /** @type {number} */\n    this.bufferSize = 2048;\n    /** @type {AudioContext} */\n    this.ctx = this.getAudioContext();\n    /** @type {GainNode} */\n    this.gainMaster = this.ctx.createGain();\n    /** @type {AudioBufferSourceNode} */\n    this.bufSrc = this.ctx.createBufferSource();\n    /** @type {Array.<number>} */\n    this.channelInstrument = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n    this.channelBank = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n    this.channelVolume = [127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127];\n    /** @type {Array.<number>} */\n    this.channelPanpot = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n    this.channelPitchBend = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n    this.channelPitchBendSensitivity = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];\n    /** @type {Array.<number>} */\n    this.channelExpression = [127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127];\n    /** @type {Array.<number>} */\n    this.channelAttack = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n    this.channelDecay = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n    this.channelSustin = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n    this.channelRelease = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n\n    /** @type {Array.<boolean>} */\n    this.channelHold = [\n      false, false, false, false, false, false, false, false,\n      false, false, false, false, false, false, false, false,\n    ];\n    /** @type {Array.<number>} */\n    this.channelReverbDepth = [40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40];\n    /** @type {Array.<number>} */\n    this.channelHarmonicContent = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n    this.channelCutOffFrequency = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n\n    /** @type {boolean} */\n    this.isGS = false;\n    /** @type {boolean} */\n    this.isXG = false;\n\n    /** @type {Array.<Array.<string>>} */\n    this.programSet = [];\n\n    /** @type {Array.<boolean>} */\n    this.channelMute = [\n      false, false, false, false, false, false, false, false,\n      false, false, false, false, false, false, false, false,\n    ];\n    /** @type {Array.<Array.<SoundFont.SynthesizerNote>>} */\n    this.currentNoteOn = [\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n      [],\n    ];\n    /** @type {number} @const */\n    this.baseVolume = 1 / 0xffff;\n    /** @type {number} */\n    this.masterVolume = 16384;\n\n    /** @type {Array.<boolean>} */\n    this.percussionPart = [\n      false, false, false, false, false, false, false, false,\n      false, true, false, false, false, false, false, false,\n    ];\n\n    /** @type {Array.<number>} */\n    this.percussionVolume = new Array(128);\n    for (i = 0, il = this.percussionVolume.length; i < il; ++i) {\n      this.percussionVolume[i] = 127;\n    }\n\n    this.programSet = {};\n\n    /** @type {boolean} */\n    this.useReverb = true;\n\n    /** @type {Reverb} */\n    this.reverb = new Reverb(this.ctx);\n  }\n\n  /**\n   * @return {AudioContext}\n   */\n  getAudioContext() {\n    /** @type {AudioContext} */\n    const ctx = new (window.AudioContext || window.webkitAudioContext)();\n\n    // for legacy browsers\n    ctx.createGain = ctx.createGain || ctx.createGainNode;\n\n    // Defreeze AudioContext for iOS.\n    const initAudioContext = () => {\n      document.removeEventListener('touchstart', initAudioContext);\n      // wake up AudioContext\n      const emptySource = ctx.createBufferSource();\n      emptySource.start();\n      emptySource.stop();\n    };\n\n    document.addEventListener('touchstart', initAudioContext);\n\n    return ctx;\n  }\n\n  /**\n   * System Reset\n   * @param {string} mode\n   */\n  init(mode = 'GM') {\n    /** @type {number} */\n    let i;\n\n    this.parser = new Parser(this.input, {\n      sampleRate: this.ctx.sampleRate,\n    });\n    this.bankSet = this.createAllInstruments();\n\n    this.isXG = false;\n    this.isGS = false;\n\n    if (mode == 'XG') {\n      this.isXG = true;\n    } else if (mode == 'GS') {\n      this.isGS = true;\n    }\n\n    for (i = 0; i < 16; ++i) {\n      this.programChange(i, 0x00);\n      this.volumeChange(i, 0x64);\n      this.panpotChange(i, 0x40);\n      this.pitchBend(i, 0x00, 0x40); // 8192\n      this.pitchBendSensitivity(i, 2);\n      this.channelHold[i] = false;\n      this.channelExpression[i] = 127;\n      this.channelBank[i] = i === 9 ? 127 : 0;\n      this.attackTime(i, 64);\n      this.decayTime(i, 64);\n      this.sustinTime(i, 64);\n      this.releaseTime(i, 64);\n      this.harmonicContent(i, 64);\n      this.cutOffFrequency(i, 64);\n      this.reverbDepth(i, 40);\n      this.updateBankSelect(i);\n      this.updateProgramSelect(i);\n    }\n\n    this.setPercussionPart(9, true);\n\n    for (i = 0; i < 128; ++i) {\n      this.percussionVolume[i] = 127;\n    }\n\n    if (this.useReverb) {\n      // エフェクターをリセット\n      this.reverb.node.disconnect(0);\n      this.gainMaster.connect(this.reverb.node);\n      this.reverb.node.connect(this.ctx.destination);\n    }\n\n    /*\n    if (this.element) {\n      this.element.querySelector('.header div:before').innerText = mode + ' Mode';\n    }\n    */\n  }\n\n  /**\n   */\n  close() {\n    this.ctx.close();\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  refreshInstruments(input) {\n    this.input = input;\n    this.parser = new Parser(input);\n    this.bankSet = this.createAllInstruments();\n  }\n\n  /** @return {Array.<Array.<Object>>} */\n  createAllInstruments() {\n    /** @type {SoundFont.Parser} */\n    const parser = this.parser;\n    parser.parse();\n    /** @type {Array} TODO */\n    const presets = parser.createPreset();\n    /** @type {Array} TODO */\n    const instruments = parser.createInstrument();\n    /** @type {Array} */\n    const banks = [];\n    /** @type {Array.<Array.<Object>>} */\n    let bank;\n    /** @type {number} */\n    let bankNumber;\n    /** @type {Object} TODO */\n    let preset;\n    /** @type {Object} */\n    let instrument;\n    /** @type {number} */\n    let presetNumber;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {number} */\n    let j;\n    /** @type {number} */\n    let jl;\n    /** @type {string} */\n    let presetName;\n\n    const programSet = [];\n\n    for (i = 0, il = presets.length; i < il; ++i) {\n      preset = presets[i];\n      presetNumber = preset.header.preset;\n      bankNumber = preset.header.bank;\n      presetName = preset.name.replace(/\\0*$/, '');\n\n      if (typeof preset.instrument !== 'number') {\n        continue;\n      }\n\n      instrument = instruments[preset.instrument];\n      if (instrument.name.replace(/\\0*$/, '') === 'EOI') {\n        continue;\n      }\n\n      // select bank\n      if (banks[bankNumber] === void 0) {\n        banks[bankNumber] = [];\n      }\n      bank = banks[bankNumber];\n      bank[presetNumber] = {};\n      bank[presetNumber].name = presetName;\n\n      for (j = 0, jl = instrument.info.length; j < jl; ++j) {\n        this.createNoteInfo(parser, instrument.info[j], bank[presetNumber]);\n      }\n      if (!programSet[bankNumber]) {\n        programSet[bankNumber] = {};\n      }\n      programSet[bankNumber][presetNumber] = presetName;\n    }\n\n    this.programSet = programSet;\n\n    return banks;\n  }\n\n  /**\n   * @param {Parser} parser\n   * @param {*} info\n   * @param {*} preset\n   */\n  createNoteInfo(parser, info, preset) {\n    /** @type {Generator} */\n    const generator = info.generator;\n\n    if (generator['keyRange'] === void 0 || generator['sampleID'] === void 0) {\n      return;\n    }\n    /** @type {number} */\n    const volDelay = this.getModGenAmount(generator, 'delayVolEnv', -12000);\n    /** @type {number} */\n    const volAttack = this.getModGenAmount(generator, 'attackVolEnv', -12000);\n    /** @type {number} */\n    const volHold = this.getModGenAmount(generator, 'holdVolEnv', -12000);\n    /** @type {number} */\n    const volDecay = this.getModGenAmount(generator, 'decayVolEnv', -12000);\n    /** @type {number} */\n    const volSustain = this.getModGenAmount(generator, 'sustainVolEnv');\n    /** @type {number} */\n    const volRelease = this.getModGenAmount(generator, 'releaseVolEnv', -12000);\n    /** @type {number} */\n    const modDelay = this.getModGenAmount(generator, 'delayModEnv', -12000);\n    /** @type {number} */\n    const modAttack = this.getModGenAmount(generator, 'attackModEnv', -12000);\n    /** @type {number} */\n    const modHold = this.getModGenAmount(generator, 'holdModEnv', -12000);\n    /** @type {number} */\n    const modDecay = this.getModGenAmount(generator, 'decayModEnv', -12000);\n    /** @type {number} */\n    const modSustain = this.getModGenAmount(generator, 'sustainModEnv');\n    /** @type {number} */\n    const modRelease = this.getModGenAmount(generator, 'releaseModEnv', -12000);\n    /** @type {number} */\n    const scale = this.getModGenAmount(generator, 'scaleTuning', 100) / 100;\n    /** @type {number} */\n    const freqVibLFO = this.getModGenAmount(generator, 'freqVibLFO');\n    /** @type {number} */\n    const pan = this.getModGenAmount(generator, 'pan');\n    /** @type {number} */\n    const tune = this.getModGenAmount(generator, 'coarseTune') + this.getModGenAmount(generator, 'fineTune') / 100;\n\n\n    for (let i = generator['keyRange'].lo, il = generator['keyRange'].hi; i <= il; ++i) {\n      if (preset[i]) {\n        continue;\n      }\n      /** @type {number} */\n      const sampleId = this.getModGenAmount(generator, 'sampleID');\n      /** @type {object} */\n      const sampleHeader = parser.sampleHeader[sampleId];\n      preset[i] = {\n        'sample': parser.sample[sampleId],\n        'sampleRate': sampleHeader.sampleRate,\n        'sampleModes': this.getModGenAmount(generator, 'sampleModes'),\n        'basePlaybackRate': Math.pow(\n          Math.pow(2, 1 / 12),\n          (\n            i -\n            this.getModGenAmount(generator, 'overridingRootKey', sampleHeader.originalPitch) +\n            tune + (sampleHeader.pitchCorrection / 100)\n          ) * scale\n        ),\n        'modEnvToPitch': this.getModGenAmount(generator, 'modEnvToPitch') / 100,\n        'scaleTuning': scale,\n        'start': this.getModGenAmount(generator, 'startAddrsCoarseOffset') * 32768 +\n          this.getModGenAmount(generator, 'startAddrsOffset'),\n        'end': this.getModGenAmount(generator, 'endAddrsCoarseOffset') * 32768 +\n          this.getModGenAmount(generator, 'endAddrsOffset'),\n        'loopStart': (\n          // (sampleHeader.startLoop - sampleHeader.start) +\n          (sampleHeader.startLoop) +\n          this.getModGenAmount(generator, 'startloopAddrsCoarseOffset') * 32768 +\n          this.getModGenAmount(generator, 'startloopAddrsOffset')\n        ),\n        'loopEnd': (\n          // (sampleHeader.endLoop - sampleHeader.start) +\n          (sampleHeader.endLoop) +\n          this.getModGenAmount(generator, 'endloopAddrsCoarseOffset') * 32768 +\n          this.getModGenAmount(generator, 'endloopAddrsOffset')\n        ),\n        'volDelay': Math.pow(2, volDelay / 1200),\n        'volAttack': Math.pow(2, volAttack / 1200),\n        'volHold': Math.pow(2, volHold / 1200) *\n          Math.pow(2, (60 - i) * this.getModGenAmount(generator, 'keynumToVolEnvHold') / 1200),\n        'volDecay': Math.pow(2, volDecay / 1200) *\n          Math.pow(2, (60 - i) * this.getModGenAmount(generator, 'keynumToVolEnvDecay') / 1200),\n        'volSustain': volSustain / 1000,\n        'volRelease': Math.pow(2, volRelease / 1200),\n        'modDelay': Math.pow(2, modDelay / 1200),\n        'modAttack': Math.pow(2, modAttack / 1200),\n        'modHold': Math.pow(2, modHold / 1200) *\n          Math.pow(2, (60 - i) * this.getModGenAmount(generator, 'keynumToModEnvHold') / 1200),\n        'modDecay': Math.pow(2, modDecay / 1200) *\n          Math.pow(2, (60 - i) * this.getModGenAmount(generator, 'keynumToModEnvDecay') / 1200),\n        'modSustain': modSustain / 1000,\n        'modRelease': Math.pow(2, modRelease / 1200),\n        'initialFilterFc': this.getModGenAmount(generator, 'initialFilterFc', 13500),\n        'modEnvToFilterFc': this.getModGenAmount(generator, 'modEnvToFilterFc'),\n        'initialFilterQ': this.getModGenAmount(generator, 'initialFilterQ'),\n        'reverbEffectSend': this.getModGenAmount(generator, 'reverbEffectSend'),\n        'initialAttenuation': this.getModGenAmount(generator, 'initialAttenuation'),\n        'freqVibLFO': freqVibLFO ? Math.pow(2, freqVibLFO / 1200) * 8.176 : void 0,\n        'pan': pan ? pan / 1200 : void 0,\n      };\n    }\n  };\n\n  /**\n   * @param {Object} generator\n   * @param {string} enumeratorType\n   * @param {number=} optDefault\n   * @return {number}\n   */\n  getModGenAmount(generator, enumeratorType, optDefault) {\n    if (optDefault === void 0) {\n      optDefault = 0;\n    }\n\n    return generator[enumeratorType] ? generator[enumeratorType].amount : optDefault;\n  }\n\n  /**\n   */\n  start() {\n    this.connect();\n    this.bufSrc.start(0);\n    this.setMasterVolume(16383);\n  }\n\n  /**\n   * @param {number} volume\n   */\n  setMasterVolume(volume) {\n    this.masterVolume = volume;\n    // this.gainMaster.gain.value = this.baseVolume * (volume / 16384);\n    this.gainMaster.gain.setTargetAtTime(this.baseVolume * (volume / 16384), this.ctx.currentTime, 0.015);\n  }\n\n  /**\n   */\n  connect() {\n    this.bufSrc.connect(this.gainMaster);\n    this.gainMaster.connect(this.ctx.destination);\n    if (this.useReverb) {\n      this.gainMaster.connect(this.reverb.node);\n      this.reverb.node.connect(this.ctx.destination);\n    }\n  }\n\n  /**\n   */\n  disconnect() {\n    this.bufSrc.disconnect(0);\n    this.gainMaster.disconnect(0);\n    if (this.useReverb) {\n      this.reverb.node.disconnect(0);\n    }\n    this.bufSrc.buffer = null;\n  }\n\n  /** @param {boolean} use */\n  setReverb(use) {\n    this.useReverb = use;\n    if (use) {\n      this.gainMaster.connect(this.reverb.node);\n      this.reverb.node.connect(this.ctx.destination);\n    } else {\n      this.reverb.node.disconnect(0);\n    }\n  }\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  drawSynth() {\n    /** @type {Document} */\n    const doc = window.document;\n    /** @type {HTMLDivElement} */\n    const wrapper = this.element = doc.createElement('div');\n    /** @type {HTMLDivElement} */\n    const instElem = doc.createElement('div');\n    instElem.className = 'instrument';\n    /** @type {Array} */\n    const items = ['mute', 'bank', 'program', 'volume', 'panpot', 'pitchBend', 'pitchBendSensitivity', 'keys'];\n    /** @type {string} */\n    const eventStart = 'ontouchstart' in window ? 'touchstart' : 'mousedown';\n    /** @type {string} */\n    const eventEnd = 'ontouchend' in window ? 'touchend' : 'mouseup';\n\n    for (let channel = 0; channel < 16; channel++) {\n      /** @type {HTMLDivElement} */\n      const channelElem = doc.createElement('div');\n      channelElem.className = 'channel';\n      for (const item in items) {\n        if ({}.hasOwnProperty.call(items, item)) {\n          /** @type {HTMLDivElement} */\n          const itemElem = doc.createElement('div');\n          itemElem.className = items[item];\n\n          switch (items[item]) {\n            case 'mute':\n              /** @type {HTMLDivElement|null} */\n              const checkboxElement = doc.createElement('div');\n              checkboxElement.className = 'custom-control custom-checkbox custom-control-inline';\n              /** @type {HTMLInputElement|null} */\n              const checkbox = doc.createElement('input');\n              checkbox.setAttribute('type', 'checkbox');\n              checkbox.className = 'custom-control-input';\n              checkbox.id = 'mute' + channel + 'ch';\n              checkbox.addEventListener('change', ((synth, channelElem) => {\n                return () => {\n                  synth.mute(channelElem, this.checked);\n                };\n              })(this, channel), false);\n              checkboxElement.appendChild(checkbox);\n              /** @type {HTMLLabelElement} */\n              const labelElem = doc.createElement('label');\n              labelElem.className = 'custom-control-label';\n              labelElem.textContent = channel + 1;\n              labelElem.setAttribute('for', 'mute' + channel + 'ch');\n              checkboxElement.appendChild(labelElem);\n              itemElem.appendChild(checkboxElement);\n              break;\n            case 'bank':\n              // Bank select\n              /** @type {HTMLSelectElement} */\n              const bankSelect = doc.createElement('select');\n              bankSelect.className = 'form-control form-control-sm';\n              itemElem.appendChild(bankSelect);\n              /** @type {HTMLOptionElement} */\n              const option = doc.createElement('option');\n              bankSelect.appendChild(option);\n\n              bankSelect.addEventListener('change', ((synth, channelElem) => {\n                return (event) => {\n                  synth.bankChange(channelElem, event.target.value);\n                  synth.programChange(channelElem, synth.channelElemInstrument[channelElem]);\n                };\n              })(this, channel), false);\n\n              bankSelect.selectedIndex = this.channelBank[item];\n              break;\n            case 'program':\n              // Program change\n              /** @type {HTMLSelectElement|null} */\n              const select = doc.createElement('select');\n              select.className = 'form-control form-control-sm';\n\n              itemElem.appendChild(select);\n\n              select.addEventListener('change', ((synth, channelElem) => {\n                return (event) => {\n                  synth.programChange(channelElem, event.target.value);\n                };\n              })(this, channel), false);\n\n              select.selectedIndex = this.channelInstrument[item];\n              break;\n            case 'volume':\n              itemElem.innerText = 100;\n            case 'pitchBendSensitivity':\n              itemElem.innerText = 2;\n              break;\n            case 'panpot':\n              /** @type {HTMLMeterElement|null} */\n              const panpot = doc.createElement('meter');\n              panpot.min = 0;\n              panpot.max = 127;\n              panpot.value = 64;\n              itemElem.appendChild(panpot);\n              break;\n            case 'pitchBend':\n              /** @type {HTMLMeterElement|null} */\n              const pitch = doc.createElement('meter');\n              pitch.min = -8192;\n              pitch.max = 8192;\n              pitch.value = 0;\n              itemElem.appendChild(pitch);\n              break;\n            case 'keys':\n              for (let key = 0; key < 127; key++) {\n                /** @type {HTMLDivElement|null} */\n                const keyElem = doc.createElement('div');\n                /** @type {number} */\n                const n = key % 12;\n                // 白鍵と黒鍵の色分け\n                keyElem.className = 'key ' + ([1, 3, 6, 8, 10].includes(n) ? 'semitone' : 'tone');\n                itemElem.appendChild(keyElem);\n\n                // イベント割当\n                keyElem.addEventListener(eventStart, ((synth, channelElem, k) => {\n                  return (event) => {\n                    event.preventDefault();\n                    synth.drag = true;\n                    synth.noteOn(channelElem, k, 127);\n                  };\n                })(this, channel, key));\n                keyElem.addEventListener('mouseover', ((synth, channelElem, k) => {\n                  return (event) => {\n                    event.preventDefault();\n                    if (synth.drag) {\n                      synth.noteOn(channelElem, k, 127);\n                    }\n                  };\n                })(this, channel, key));\n                keyElem.addEventListener('mouseout', ((synth, channelElem, k) => {\n                  return (event) => {\n                    event.preventDefault();\n                    synth.noteOff(channelElem, k, 0);\n                  };\n                })(this, channel, key));\n                keyElem.addEventListener(eventEnd, ((synth, channelElem, k) => {\n                  return (event) => {\n                    event.preventDefault();\n                    synth.drag = false;\n                    synth.noteOff(channelElem, k, 0);\n                  };\n                })(this, channel, key));\n              }\n              break;\n          }\n          channelElem.appendChild(itemElem);\n        }\n      }\n      instElem.appendChild(channelElem);\n    }\n    wrapper.appendChild(instElem);\n    return wrapper;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} key\n   * @param {number} velocity\n   */\n  updateSynthElement(channel, key, velocity) {\n    if (!this.element) {\n      return;\n    }\n    /** @type {HTMLDivElement} */\n    const keyElem = this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') .key:nth-child(' + (key + 1) + ')');\n\n    if (velocity === 0) {\n      keyElem.classList.remove('note-on');\n      keyElem.style.opacity = 1;\n    } else {\n      keyElem.classList.add('note-on');\n      keyElem.style.opacity = (velocity / 127).toFixed(2);\n    }\n  }\n\n  /**\n   * @param {number} channel\n   */\n  updateBankSelect(channel) {\n    if (!this.element) {\n      return;\n    }\n    /** @type {HTMLElement} */\n    const bankElement = this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') .bank > select');\n\n    while (bankElement.firstChild) bankElement.removeChild(bankElement.firstChild);\n\n    for (const bankNo in this.programSet) {\n      if ({}.hasOwnProperty.call(this.programSet, bankNo)) {\n        const option = document.createElement('option');\n        option.value = bankNo;\n        option.textContent = ('000' + (parseInt(bankNo))).slice(-3);\n        bankElement.appendChild(option);\n      }\n    }\n  }\n\n  /**\n   * @param {number} channel\n   */\n  updateProgramSelect(channel) {\n    if (!this.element) {\n      return;\n    }\n    /** @type {number} */\n    const bankIndex = this.channelBank[channel];\n    /** @type {HTMLElement} */\n    const bankElement = this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') .bank > select');\n    /** @type {HTMLElement} */\n    const programElement = this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') .program > select');\n\n    bankElement.value = this.channelBank[channel];\n    while (programElement.firstChild) programElement.removeChild(programElement.firstChild);\n\n    for (const programNo in this.programSet[bankIndex]) {\n      if ({}.hasOwnProperty.call(this.programSet[bankIndex], programNo)) {\n        // TODO: 存在しないプログラムの場合、現状では空白になってしまう\n        const option = document.createElement('option');\n        option.value = programNo;\n        option.textContent = ('000' + (parseInt(programNo) + 1)).slice(-3) + ':' + this.programSet[bankIndex][programNo];\n        if (programNo === this.channelInstrument[channel]) {\n          option.selected = 'selected';\n        }\n        programElement.appendChild(option);\n      }\n    }\n  }\n\n  /**\n   * @param {number} channel NoteOn するチャンネル.\n   * @param {number} key NoteOn するキー.\n   * @param {number} velocity 強さ.\n   */\n  noteOn(channel, key, velocity) {\n    /** @type {number} */\n    const bankIndex = this.channelBank[channel];\n    /** @type {Object} */\n    const bank = (typeof this.bankSet[bankIndex] === 'object') ? this.bankSet[bankIndex] : this.bankSet[0];\n    /** @type {Object} */\n    let instrument;\n\n    if (typeof bank[this.channelInstrument[channel]] === 'object') {\n      // 音色が存在する場合\n      instrument = bank[this.channelInstrument[channel]];\n    } else if (this.percussionPart[channel] == true) {\n      // パーカッションバンクが選択されている場合で音色が存在しない場合Standard Kitを選択\n      instrument = this.bankSet[(this.isXG ? 127 : 128)][0];\n    } else {\n      // 通常バンクが選択されている状態で音色が存在しない場合バンク0を選択\n      instrument = this.bankSet[0][this.channelInstrument[channel]];\n    }\n\n    if (instrument[key] === void 0) {\n      // TODO\n      console.warn(\n        'instrument not found: bank=%s instrument=%s channel=%s key=%s',\n        bankIndex,\n        this.channelInstrument[channel],\n        channel,\n        key\n      );\n      return;\n    }\n    /** @type {Object} */\n    const instrumentKey = instrument[key];\n    /** @type {number} */\n    let panpot = this.channelPanpot[channel] - 64;\n    panpot /= panpot < 0 ? 64 : 63;\n\n    // create note information\n    instrumentKey['channel'] = channel;\n    instrumentKey['key'] = key;\n    instrumentKey['velocity'] = velocity;\n    instrumentKey['panpot'] = panpot;\n    instrumentKey['volume'] = this.channelVolume[channel] / 127;\n    instrumentKey['pitchBend'] = this.channelPitchBend[channel] - 8192;\n    instrumentKey['expression'] = this.channelExpression[channel];\n    instrumentKey['pitchBendSensitivity'] = Math.round(this.channelPitchBendSensitivity[channel]);\n    instrumentKey['mute'] = this.channelMute[channel];\n    instrumentKey['releaseTime'] = this.channelRelease[channel];\n    instrumentKey['cutOffFrequency'] = this.cutOffFrequency[channel];\n    instrumentKey['harmonicContent'] = this.harmonicContent[channel];\n\n    // percussion\n    if (bankIndex > 125) {\n      if (key === 42 || key === 44) {\n        // 42: Closed Hi-Hat\n        // 44: Pedal Hi-Hat\n        // 46: Open Hi-Hat\n        this.noteOff(channel, 46, 0);\n      }\n      if (key === 80) {\n        // 80: Mute Triangle\n        // 81: Open Triangle\n        this.noteOff(channel, 81, 0);\n      }\n      instrument['volume'] *= this.percussionVolume[key] / 127;\n    }\n\n    // note on\n    /** @type {SynthesizerNote} */\n    const note = new SynthesizerNote(this.ctx, this.gainMaster, instrumentKey);\n    note.noteOn();\n    this.currentNoteOn[channel].push(note);\n\n    this.updateSynthElement(channel, key, velocity);\n  }\n\n  /**\n   * @param {number} channel NoteOff するチャンネル.\n   * @param {number} key NoteOff するキー.\n   * @param {number} velocity 強さ.\n   */\n  noteOff(channel, key, velocity) {\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {SynthesizerNote} */\n    let note;\n    /** @type {boolean} */\n    const hold = this.channelHold[channel];\n\n    for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n      note = currentNoteOn[i];\n      if (note.key === key) {\n        note.noteOff();\n        // hold している時は NoteOff にはするがリリースはしない\n        if (!hold) {\n          note.release();\n          currentNoteOn.splice(i, 1);\n          --i;\n          --il;\n        }\n      }\n    }\n    this.updateSynthElement(channel, key, 0);\n  }\n\n  /**\n   * @param {number} channel ホールドするチャンネル\n   * @param {number} value 値\n   */\n  hold(channel, value) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {boolean} */\n    const hold = this.channelHold[channel] = !(value < 64);\n    /** @type {SynthesizerNote} */\n    let note;\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n\n    if (!hold) {\n      for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n        note = currentNoteOn[i];\n        if (note.isNoteOff()) {\n          note.release();\n          currentNoteOn.splice(i, 1);\n          --i;\n          --il;\n        }\n      }\n    }\n\n    if (this.element) {\n      /** @type {HTMLDivElement} */\n      const channelElement = this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ')');\n      if (this.channelHold[channel]) {\n        channelElement.classList.add('hold');\n      } else {\n        channelElement.classList.remove('hold');\n      }\n    }\n  }\n\n  /**\n   * @param {number} channel チャンネルのバンクセレクトMSB\n   * @param {number} value 値\n   */\n  bankSelectMsb(channel, value) {\n    if (this.isXG) {\n      // 念の為バンクを0にリセット\n      this.channelBank[channel] = 0;\n      // XG音源は、MSB→LSBの優先順でバンクセレクトをする。\n      if (value === 64) {\n        // Bank Select MSB #64 (Voice Type: SFX)\n        this.channelBank[channel] = 125;\n        this.percussionPart[channel] = true;\n      } else if (value === 126 || value === 127) {\n        // Bank Select MSB #126 (Voice Type: Drum)\n        // Bank Select MSB #127 (Voice Type: Drum)\n        this.channelBank[channel] = value;\n        this.percussionPart[channel] = true;\n      }\n    } else if (this.isGS) {\n      // GS音源\n      // ※チャンネル10のバンク・セレクト命令は無視する。\n      this.channelBank[channel] = channel === 9 ? 128 : value;\n      this.percussionPart[channel] = value === 128;\n    } else {\n      // GM音源モードのときはバンク・セレクトを無視\n      return;\n    }\n    this.updateBankSelect(channel);\n  }\n\n  /**\n   * @param {number} channel チャンネルのバンクセレクトLSB\n   * @param {number} value 値\n   */\n  bankSelectLsb(channel, value) {\n    // XG音源以外は処理しない\n    if (!this.isXG || this.percussionPart[channel] === true) {\n      return;\n    }\n\n    // 125より値が大きい場合、パーカッションとして処理\n    this.percussionPart[channel] = value >= 125;\n\n    this.channelBank[channel] = value;\n    this.updateBankSelect(channel);\n  }\n\n  /**\n   * @param {number} channel 音色を変更するチャンネル.\n   * @param {number} instrument 音色番号.\n   */\n  programChange(channel, instrument) {\n    this.channelInstrument[channel] = instrument;\n\n    this.bankChange(channel, this.channelBank[channel]);\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') .program > select').value = instrument;\n    }\n  }\n\n  /**\n   * @param {number} channel 音色を変更するチャンネル.\n   * @param {number} bank バンク・セレクト.\n   */\n  bankChange(channel, bank) {\n    if (typeof this.bankSet[bank] === 'object') {\n      // バンクが存在するとき\n      this.channelBank[channel] = bank;\n    } else {\n      // バンクが存在しないとき\n      if (this.percussionPart[channel]) {\n        // パーカッション\n        this.channelBank[channel] = !this.isXG ? 128 : 127;\n      } else {\n        // 存在しない場合0を選択\n        this.channelBank[channel] = 0;\n      }\n    }\n\n    // TODO: 厳密にはMIDI音源はプログラムチェンジがあったときにバンク・セレクトが反映される。\n    this.updateProgramSelect(channel);\n\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .bank > select').value = bank;\n    }\n  }\n\n  /**\n   * @param {number} channel 音量を変更するチャンネル.\n   * @param {number} volume 音量(0-127).\n   */\n  volumeChange(channel, volume) {\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .volume').innerText = volume;\n    }\n    this.channelVolume[channel] = volume;\n  }\n\n  /**\n   * @param {number} channel 音量を変更するチャンネル.\n   * @param {number} expression 音量(0-127).\n   */\n  expression(channel, expression) {\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n\n    for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n      currentNoteOn[i].updateExpression(expression);\n    }\n\n    this.channelExpression[channel] = expression;\n  }\n\n  /**\n   * @param {number} channel panpot を変更するチャンネル.\n   * @param {number} panpot panpot(0-127).\n   */\n  panpotChange(channel, panpot) {\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .panpot > meter').value = panpot;\n    }\n\n    this.channelPanpot[channel] = panpot;\n  }\n\n  /**\n   * @param {number} channel panpot を変更するチャンネル.\n   * @param {number} lowerByte\n   * @param {number} higherByte\n   */\n  pitchBend(channel, lowerByte, higherByte) {\n    /** @type {number} */\n    const bend = (lowerByte & 0x7f) | ((higherByte & 0x7f) << 7);\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n    /** @type {Array.<SoundFont.SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {number} */\n    const calculated = bend - 8192;\n\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .pitchBend > meter').value = calculated;\n    }\n\n    for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n      currentNoteOn[i].updatePitchBend(calculated);\n    }\n\n    this.channelPitchBend[channel] = bend;\n  }\n\n  /**\n   * @param {number} channel pitch bend sensitivity を変更するチャンネル.\n   * @param {number} sensitivity\n   */\n  pitchBendSensitivity(channel, sensitivity) {\n    if (this.element) {\n      document.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .pitchBendSensitivity').innerText = sensitivity;\n    }\n    this.channelPitchBendSensitivity[channel] = sensitivity;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} attackTime\n   */\n  attackTime(channel, attackTime) {\n    this.channelAttack[channel] = attackTime;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} decayTime\n   */\n  decayTime(channel, decayTime) {\n    this.channelDecay[channel] = decayTime;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} sustinTime\n   */\n  sustinTime(channel, sustinTime) {\n    this.channelSustin[channel] = sustinTime;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} releaseTime\n   */\n  releaseTime(channel, releaseTime) {\n    this.channelRelease[channel] = releaseTime;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} value\n   */\n  harmonicContent(channel, value) {\n    this.channelHarmonicContent[channel] = value;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} value\n   */\n  cutOffFrequency(channel, value) {\n    this.channelCutOffFrequency[channel] = value;\n  }\n\n  /**\n   * @param {number} channel\n   * @param {number} depth\n   */\n  reverbDepth(channel, depth) {\n    this.reverbDepth[channel] = depth;\n  }\n\n  /**\n   * @param {number} channel pitch bend sensitivity を取得するチャンネル.\n   * @return {number}\n   */\n  getPitchBendSensitivity(channel) {\n    return this.channelPitchBendSensitivity[channel];\n  }\n\n  /**\n   * @param {number} key\n   * @param {number} volume\n   */\n  drumInstrumentLevel(key, volume) {\n    this.percussionVolume[key] = volume;\n  }\n\n  /**\n   * @param {number} channel NoteOff するチャンネル.\n   */\n  allNoteOff(channel) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n\n    // ホールドを解除\n    this.hold(channel, 0);\n\n    // 再生中の音をすべて止める\n    while (currentNoteOn.length > 0) {\n      this.noteOff(channel, currentNoteOn[0].key, 0);\n    }\n  }\n\n  /**\n   * @param {number} channel 音を消すチャンネル.\n   */\n  allSoundOff(channel) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {SynthesizerNote} */\n    let note;\n\n    while (currentNoteOn.length > 0) {\n      note = currentNoteOn.shift();\n      this.noteOff(channel, note.key, 0);\n      note.release();\n      note.disconnect();\n    }\n\n    // ホールドを解除\n    this.hold(channel, 0);\n  }\n\n  /**\n   * @param {number} channel リセットするチャンネル\n   */\n  resetAllControl(channel) {\n    this.allNoteOff(channel);\n    this.expression(channel, 127);\n    this.pitchBend(channel, 0x00, 0x40);\n  }\n\n  /**\n   * @param {number} channel ミュートの設定を変更するチャンネル.\n   * @param {boolean} mute ミュートにするなら true.\n   */\n  mute(channel, mute) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n    let il;\n\n    this.channelMute[channel] = mute;\n\n    if (mute) {\n      for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n        currentNoteOn[i].disconnect();\n      }\n    } else {\n      for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n        currentNoteOn[i].connect();\n      }\n    }\n  }\n\n  /**\n   * @param {number} channel TODO:ドラムパートとしてセットするチャンネル\n   * @param {boolean} sw ドラムか通常かのスイッチ\n   */\n  setPercussionPart(channel, sw) {\n    if (!this.isXG) {\n      this.channelBank[channel] = 128;\n    } else {\n      this.channelBank[channel] = 127;\n    }\n    this.percussionPart[channel] = sw;\n  }\n}\n\nexport default Synthesizer;\n","/**\n * SynthesizerNote Class\n * @private\n */\nexport class SynthesizerNote {\n  /**\n   * @param {AudioContext} ctx\n   * @param {AudioNode} destination\n   * @param {{\n   *   channel: number,\n   *   key: number,\n   *   sample: Uint8Array,\n   *   basePlaybackRate: number,\n   *   loopStart: number,\n   *   loopEnd: number,\n   *   volume: number,\n   *   panpot: number\n   * }} instrument\n   */\n  constructor(ctx, destination, instrument) {\n    /** @type {AudioContext} */\n    this.ctx = ctx;\n    /** @type {AudioNode} */\n    this.destination = destination;\n    /** @type {{\n     *   channel: number,\n     *   key: number,\n     *   sample: Uint8Array,\n     *   basePlaybackRate: number,\n     *   loopStart: number,\n     *   loopEnd: number,\n     *   volume: number,\n     *   panpot: number\n     * }}\n     */\n    this.instrument = instrument;\n    /** @type {number} */\n    this.channel = instrument['channel'];\n    /** @type {number} */\n    this.key = instrument['key'];\n    /** @type {number} */\n    this.velocity = instrument['velocity'];\n    /** @type {Int16Array} */\n    this.buffer = instrument['sample'];\n    /** @type {number} */\n    this.playbackRate = instrument['basePlaybackRate'];\n    /** @type {number} */\n    this.loopStart = instrument['loopStart'];\n    /** @type {number} */\n    this.loopEnd = instrument['loopEnd'];\n    /** @type {number} */\n    this.sampleRate = instrument['sampleRate'];\n    /** @type {number} */\n    this.volume = instrument['volume'];\n    /** @type {number} */\n    this.panpot = instrument['panpot'];\n    /** @type {number} */\n    this.pitchBend = instrument['pitchBend'];\n    /** @type {number} */\n    this.pitchBendSensitivity = instrument['pitchBendSensitivity'];\n    /** @type {number} */\n    this.modEnvToPitch = instrument['modEnvToPitch'];\n    /** @type {number} */\n    this.expression = instrument['expression'];\n    /** @type {number} */\n    this.cutOffFrequency = instrument['cutOffFrequency'];\n    /** @type {number} */\n    this.hermonicContent = instrument['hermonicContent'];\n\n    // state\n    /** @type {number} */\n    this.startTime = ctx.currentTime;\n    /** @type {number} */\n    this.computedPlaybackRate = this.playbackRate | 0;\n    /** @type {boolean} */\n    this.noteOffState = false;\n\n    // ---------------------------------------------------------------------------\n    // audio node\n    // ---------------------------------------------------------------------------\n\n    /** @type {AudioBuffer} */\n    this.audioBuffer;\n    /** @type {AudioBufferSourceNode} */\n    this.bufferSource = ctx.createBufferSource();\n    /** @type {StereoPannerNode} */\n    this.panner = ctx.createPanner();\n    /** @type {GainNode} */\n    this.outputGainNode = ctx.createGain ? ctx.createGain() : ctx.createGainNode();\n    /** @type {GainNode} */\n    this.expressionGainNode = ctx.createGain ? ctx.createGain() : ctx.createGainNode();\n    /** @type {BiquadFilterNode} */\n    this.filter = ctx.createBiquadFilter();\n    /** @type {BiquadFilterNode} */\n    this.modulator = ctx.createBiquadFilter();\n  }\n\n  /**\n   */\n  noteOn() {\n    /** @type {AudioContext} */\n    const ctx = this.ctx;\n    /** @type {{\n     *   channel: number,\n     *   key: number,\n     *   sample: Uint8Array,\n     *   basePlaybackRate: number,\n     *   loopStart: number,\n     *   loopEnd: number,\n     *   volume: number,\n     *   panpot: number\n     * }} */\n    const instrument = this.instrument;\n    /** @type {number} */\n    const now = this.ctx.currentTime || 0;\n    /** @type {number} */\n    const volDelay = now + instrument['volDelay'];\n    /** @type {number} */\n    const modDelay = now + instrument['modDelay'];\n    /** @type {number} */\n    const volAttack = volDelay + instrument['volAttack'];\n    /** @type {number} */\n    const modAttack = volDelay + instrument['modAttack'];\n    /** @type {number} */\n    const volHold = volAttack + instrument['volHold'];\n    /** @type {number} */\n    const modHold = modAttack + instrument['modHold'];\n    /** @type {number} */\n    const volDecay = volHold + instrument['volDecay'];\n    /** @type {number} */\n    const modDecay = modHold + instrument['modDecay'];\n    /** @type {number} */\n    const loopStart = instrument['loopStart'] / this.sampleRate;\n    /** @type {number} */\n    const loopEnd = instrument['loopEnd'] / this.sampleRate;\n    /** @type {number} */\n    const startTime = instrument['start'] / this.sampleRate;\n    // TODO: ドラムパートのPanが変化した場合、その計算をしなければならない\n    // http://cpansearch.perl.org/src/PJB/MIDI-SoundFont-1.08/doc/sfspec21.html#8.4.6\n    /** @type {number} */\n    const pan = instrument['pan'] !== void 0 ? instrument['pan'] : this.panpot;\n    /** @type {number} */\n    // const cutOffFrequency = instrument['cutOffFrequency']; // (Brightness)\n    /** @type {number} */\n    // const harmonicContent = instrument['harmonicContent']; // (Resonance)\n\n    const sample = this.buffer.subarray(0, this.buffer.length + instrument['end']);\n    /** @type {AudioBuffer} */\n    const buffer = this.audioBuffer = ctx.createBuffer(1, sample.length, this.sampleRate);\n    /** @type {Float32Array} */\n    const channelData = buffer.getChannelData(0);\n    channelData.set(sample);\n\n    // buffer source\n    /** @type {AudioBufferSourceNode} */\n    const bufferSource = this.bufferSource;\n    bufferSource.buffer = buffer;\n    bufferSource.loop = instrument['sampleModes'];\n    bufferSource.loopStart = loopStart;\n    bufferSource.loopEnd = loopEnd;\n    this.updatePitchBend(this.pitchBend);\n\n    // Output\n    /** @type {GainNode} */\n    const output = this.outputGainNode;\n\n    // expression\n    // this.expressionGainNode.gain.value = this.expression / 127;\n    this.expressionGainNode.gain.setTargetAtTime(this.expression / 127, this.startTime, 0.015);\n\n    // panpot\n    /** @type {StereoPannerNode} */\n    const panner = this.panner;\n    panner.panningModel = 'equalpower';\n    // panner.distanceModel = 'inverse';\n    panner.setPosition(\n      Math.sin(pan * Math.PI / 2),\n      0,\n      Math.cos(pan * Math.PI / 2)\n    );\n\n    // ---------------------------------------------------------------------------\n    // Delay, Attack, Hold, Decay, Sustain\n    // ---------------------------------------------------------------------------\n\n    /** @type {number} */\n    let volume = this.volume * (this.velocity / 127) * (1 - instrument['initialAttenuation'] / 1000);\n    if (volume < 0) {\n      volume = 0;\n    }\n\n    // volume envelope\n    /** @type {AudioNode} */\n    const outputGain = output.gain;\n    outputGain.setValueAtTime(0, now);\n    outputGain.setValueAtTime(0, volDelay);\n    outputGain.setTargetAtTime(volume, volDelay, instrument['volAttack']);\n    outputGain.setValueAtTime(volume, volHold);\n    outputGain.linearRampToValueAtTime(volume * (1 - instrument['volSustain']), volDecay);\n\n    // modulation envelope\n    /** @type {number} */\n    const baseFreq = this.amountToFreq(instrument['initialFilterFc']);\n    /** @type {number} */\n    const peekFreq = this.amountToFreq(instrument['initialFilterFc'] + instrument['modEnvToFilterFc']);\n    /** @type {number} */\n    const sustainFreq = baseFreq + (peekFreq - baseFreq) * (1 - instrument['modSustain']);\n\n    /** @type {BiquadFilterNode} */\n    const modulator = this.modulator;\n    modulator.Q.setValueAtTime(Math.pow(10, instrument['initialFilterQ'] / 200), now);\n    // modulator.frequency.value = baseFreq;\n    modulator.type = 'lowpass';\n    modulator.frequency.setTargetAtTime(baseFreq / 127, this.ctx.currentTime, 0.5);\n    modulator.frequency.setValueAtTime(baseFreq, now);\n    modulator.frequency.setValueAtTime(baseFreq, modDelay);\n    modulator.frequency.setTargetAtTime(peekFreq, modDelay, parseFloat(instrument['modAttack'] + 1)); // For FireFox fix\n    modulator.frequency.setValueAtTime(peekFreq, modHold);\n    modulator.frequency.linearRampToValueAtTime(sustainFreq, modDecay);\n\n    // filter\n    /*\n    const filter = this.filter = ctx.createBiquadFilter();\n    filter.type = 'lowpass';\n    filter.frequency.value = this.ctx.sampleRate / 2;\n    filter.gain.value = 0;\n    filter.Q.value = 0;\n    // console.log(this.sampleRate, 'Hz');\n    filter.frequency.value = (cutOffFrequency / this.sampleRate) * 100000; // Brightness = 0 ~ 127  64 = 350 / LPF 100~20000\n    // console.log('Brightness:', cutOffFrequency, ' = ', filter.frequency.value, 'Hz');\n    filter.Q.value = harmonicContent < 0 ? 0 : harmonicContent - 64; // Resonance 0 ~ 127 / Q = 0~50\n    // console.log('Resonance:', harmonicContent, ' = ', filter.Q.value);\n    */\n\n    // connect\n    bufferSource.connect(modulator);\n    modulator.connect(panner);\n    panner.connect(this.expressionGainNode);\n\n    /*\n    this.expressionGainNode.connect(filter);\n    filter.connect(output);\n    */\n    this.expressionGainNode.connect(output);\n\n    if (!instrument['mute']) {\n      this.connect();\n    }\n\n    // fire\n    bufferSource.start(0, startTime);\n  }\n\n  /**\n   * @param {number} val\n   * @return {number}\n   */\n  amountToFreq(val) {\n    return Math.pow(2, (val - 6900) / 1200) * 440;\n  }\n\n  /**\n   */\n  noteOff() {\n    this.noteOffState = true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isNoteOff() {\n    return this.noteOffState;\n  }\n\n  /**\n   * @return {void}\n   */\n  release() {\n    /** @type {{\n     *   channel: number,\n     *   key: number,\n     *   sample: Uint8Array,\n     *   basePlaybackRate: number,\n     *   loopStart: number,\n     *   loopEnd: number,\n     *   volume: number,\n     *   panpot: number\n     * }} */\n    const instrument = this.instrument;\n    /** @type {AudioBufferSourceNode} */\n    const bufferSource = this.bufferSource;\n    /** @type {GainNode} */\n    const output = this.outputGainNode;\n    /** @type {number} */\n    const now = this.ctx.currentTime;\n    const release = instrument['releaseTime'] - 64;\n\n    // ---------------------------------------------------------------------------\n    // volume release time\n    // ---------------------------------------------------------------------------\n    /** @type {number} */\n    const volEndTimeTmp = instrument['volRelease'] * output.gain.value;\n    /** @type {number} */\n    const volEndTime = now + (volEndTimeTmp * (1 + release / (release < 0 ? 64 : 63)));\n    // var volEndTime = now + instrument['volRelease'] * (1 - instrument['volSustain']);\n\n    // ---------------------------------------------------------------------------\n    // modulation release time\n    // ---------------------------------------------------------------------------\n    /** @type {BiquadFilterNode} */\n    const modulator = this.modulator;\n    /** @type {number} */\n    const baseFreq = this.amountToFreq(instrument['initialFilterFc']);\n    /** @type {number} */\n    const peekFreq = this.amountToFreq(instrument['initialFilterFc'] + instrument['modEnvToFilterFc']);\n    /** @type {number} */\n    const modEndTime = now + instrument['modRelease'] *\n      (\n        baseFreq === peekFreq ?\n          1 :\n          (modulator.frequency.value - baseFreq) / (peekFreq - baseFreq)\n      );\n    // var modEndTime = now + instrument['modRelease'] * (1 - instrument['modSustain']);\n\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    // ---------------------------------------------------------------------------\n    // Release\n    // ---------------------------------------------------------------------------\n\n    switch (instrument['sampleModes']) {\n      case 0:\n        break;\n      case 1:\n        output.gain.cancelScheduledValues(0);\n        output.gain.setValueAtTime(output.gain.value, now);\n        output.gain.linearRampToValueAtTime(0, volEndTime);\n\n        modulator.frequency.cancelScheduledValues(0);\n        modulator.frequency.setValueAtTime(modulator.frequency.value, now);\n        modulator.frequency.linearRampToValueAtTime(baseFreq, modEndTime);\n\n        bufferSource.playbackRate.cancelScheduledValues(0);\n        bufferSource.playbackRate.setValueAtTime(bufferSource.playbackRate.value, now);\n        bufferSource.playbackRate.linearRampToValueAtTime(this.computedPlaybackRate, modEndTime);\n\n        bufferSource.stop(volEndTime);\n        break;\n      case 2:\n        console.log('detect unused sampleModes');\n        break;\n      case 3:\n        bufferSource.loop = false;\n        bufferSource.disconnect();\n        bufferSource.buffer = null;\n        break;\n    }\n  }\n\n  /**\n   */\n  connect() {\n    this.outputGainNode.connect(this.destination);\n  }\n\n  /**\n   */\n  disconnect() {\n    this.outputGainNode.disconnect(0);\n  }\n  /**\n   */\n  schedulePlaybackRate() {\n    const playbackRate = this.bufferSource.playbackRate;\n    /** @type {number} */\n    const computed = this.computedPlaybackRate;\n    /** @type {number} */\n    const start = this.startTime;\n    /** @type {Object} */\n    const instrument = this.instrument;\n    /** @type {number} */\n    const modAttack = start + instrument['modAttack'];\n    /** @type {number} */\n    const modDecay = modAttack + instrument['modDecay'];\n    /** @type {number} */\n    const peekPitch = computed * Math.pow(\n      Math.pow(2, 1 / 12),\n      this.modEnvToPitch * this.instrument['scaleTuning']\n    );\n\n    playbackRate.cancelScheduledValues(0);\n    playbackRate.setValueAtTime(computed, start);\n    playbackRate.linearRampToValueAtTime(peekPitch, modAttack);\n    playbackRate.linearRampToValueAtTime(computed + (peekPitch - computed) * (1 - instrument['modSustain']), modDecay);\n  }\n\n  /**\n   * @param {number} expression\n   */\n  updateExpression(expression) {\n    // this.expressionGain.gain.value = (this.expression = expression) / 127;\n    this.expressionGainNode.gain.setTargetAtTime((this.expression = expression) / 127, this.ctx.currentTime, 0.015);\n  }\n\n  /**\n   * @param {number} pitchBend\n   */\n  updatePitchBend(pitchBend) {\n    this.computedPlaybackRate = this.playbackRate * Math.pow(\n      Math.pow(2, 1 / 12),\n      (pitchBend / (pitchBend < 0 ? 8192 : 8191)) *\n      this.pitchBendSensitivity *\n      this.instrument['scaleTuning']\n    );\n    this.schedulePlaybackRate();\n  }\n}\n\nexport default SynthesizerNote;\n","import Synthesizer from './sound_font_synth';\n\n/**\n * WebMidiLink Class\n */\nexport class WebMidiLink {\n  /**\n   * @param {object} option\n   */\n  constructor(option = {}) {\n    /** @type {Array.<number>} */\n    this.NrpnMsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n    this.NrpnLsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n    this.RpnMsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n    this.RpnLsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {boolean} */\n    this.ready = false;\n    /** @type {Synthesizer} */\n    this.synth;\n    /** @type {function(ArrayBuffer)} */\n    this.loadCallback = () => { };\n    /** @type {Function} */\n    this.messageHandler = this.onmessage.bind(this);\n    /** @type {XMLHttpRequest} */\n    this.xhr;\n    /** @type {boolean} */\n    this.rpnMode = true;\n    /** @type {object} */\n    this.option = option;\n    /** @type {boolean} */\n    this.option.drawSynth = option.drawSynth !== void 0 ? option.drawSynth : true;\n    /** @type {boolean} */\n    this.option.cache = option.cache !== void 0 ? option.cache : true;\n    /** @type {HTMLElement} */\n    this.placeholder = option.placeholder !== void 0 ? document.getElementById(option.placeholder) : window.document.body;\n    /** @type {Window} */\n    this.opener;\n\n    // eslint-disable-next-line space-before-function-paren\n    window.addEventListener('DOMContentLoaded', function () {\n      this.ready = true;\n    }.bind(this), false);\n  };\n\n  /**\n   * @param {string} url\n   * @export\n   */\n  setup(url) {\n    /** @type {Window} */\n    const w = window;\n\n    if (!this.ready) {\n      w.addEventListener('DOMContentLoaded', function onload() {\n        w.removeEventListener('DOMContentLoaded', onload, false);\n        this.load(url);\n      }.bind(this), false);\n    } else {\n      this.load(url);\n    }\n\n    if (w.opener) {\n      this.opener = w.opener;\n    } else if (w.parent !== w) {\n      this.opener = w.parent;\n    }\n  }\n\n  /**\n   * @param {string} url\n   * @export\n   */\n  load(url) {\n    /** @type {Window} */\n    const opener = window.opener ? window.opener : window.parent;\n    /** @type {WebMidiLink} */\n    const self = this;\n    /** @type {HtmlDIVElement} */\n    const loading = this.placeholder.appendChild(document.createElement('div'));\n\n    opener.postMessage('link,progress', '*');\n\n    const ready = (stream) => {\n      console.info('ready');\n      self.placeholder.removeChild(loading);\n      self.onload(stream);\n      if (typeof self.loadCallback === 'function') {\n        self.loadCallback(stream);\n      }\n      opener.postMessage('link,ready', '*');\n    };\n\n    if (this.option.cache && window.caches) {\n      // キャッシュが利用可能な場合\n\n      loading.className = 'd-flex';\n\n      /** @type {HTMLDivElement} */\n      const spiner = loading.appendChild(document.createElement('div'));\n      spiner.className = 'spinner-border text-primary';\n      spiner.role = 'status';\n      spiner.ariaHidden = true;\n\n      /** @type {HTMLStrongElement} */\n      const loadingText = loading.appendChild(document.createElement('strong'));\n      loadingText.className = 'ml-1';\n      loadingText.innerText = 'Now Loading...';\n\n      window.caches.open('wml').then((cache) => {\n        cache\n          .match(url)\n          .then((response) => response.arrayBuffer())\n          .then((stream) => ready(stream))\n          .catch(() => {\n            console.info('Fetch from server.');\n            fetch(url)\n              .then((response) => {\n                if (!response.ok) {\n                  throw new Error('Network response was not ok.');\n                }\n                const copy = response.clone();\n                cache.put(url, response);\n                return copy.arrayBuffer();\n              })\n              .then((stream) => ready(stream))\n              .catch((e) => alert('There has been a problem with your fetch operation: ' + e.message));\n          });\n      });\n    } else {\n      // キャッシュが使えない場合\n      console.info('This server/client does not cache function.');\n\n      // プログレスバーを表示\n\n      /** @type {HTMLDivElement} */\n      const progress =\n        loading.appendChild(document.createElement('div'));\n      progress.className = 'progress';\n      /** @type {HTMLDivElement} */\n      const progressBar =\n        progress.appendChild(document.createElement('div'));\n      progressBar.className = 'progress-bar';\n      progressBar.role = 'progressbar';\n      progressBar.innerText = '0%';\n\n      // 結合処理\n      const concatenation = (segments) => {\n        let sumLength = 0;\n        for (let i = 0; i < segments.length; ++i) {\n          sumLength += segments[i].byteLength;\n        }\n        const whole = new Uint8Array(sumLength);\n        let pos = 0;\n        for (let i = 0; i < segments.length; ++i) {\n          whole.set(new Uint8Array(segments[i]), pos);\n          pos += segments[i].byteLength;\n        }\n        return whole.buffer;\n      };\n\n      fetch(url)\n        .then((res) => {\n          // 全体サイズ\n          const total = res.headers.get('content-length');\n          progress.max = total;\n\n          // body の reader を取得する\n          const reader = res.body.getReader();\n          let chunk = 0;\n          const buffer = [];\n          const processResult = (result) => {\n            // done が true なら最後の chunk\n            if (result.done) {\n              const stream = concatenation(buffer);\n              ready(stream);\n              return;\n            }\n\n            // chunk の長さの蓄積を total で割れば進捗が分かる\n            chunk += result.value.length;\n            buffer.push(result.value);\n            // 進捗を更新\n            const percentage = Math.round((chunk / total) * 100);\n            progressBar.style.width = percentage + '%';\n            progressBar.innerText = percentage + ' %';\n            opener.postMessage('link,progress,' + chunk + ',' + total, '*');\n\n            // 再帰する\n            return reader.read().then(processResult);\n          };\n          reader.read().then(processResult);\n        })\n        .catch((e) => alert('There has been a problem with your fetch operation: ' + e.message));\n    }\n  }\n\n  /**\n   * @param {boolean} sw\n   * @export\n   */\n  setReverb(sw) {\n    this.synth.setReverb(sw);\n  }\n\n  /**\n   * @param {ArrayBuffer} response\n   */\n  onload(response) {\n    /** @type {Uint8Array} */\n    const input = new Uint8Array(response);\n\n    this.loadSoundFont(input);\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  loadSoundFont(input) {\n    /** @type {Synthesizer} */\n    let synth;\n    /** @type {Window} */\n    const w = window;\n\n    if (!this.synth) {\n      synth = this.synth = new Synthesizer(input);\n      if (this.option.drawSynth) {\n        this.placeholder.appendChild(synth.drawSynth());\n      }\n      synth.init();\n      synth.start();\n      w.addEventListener('message', this.messageHandler, false);\n    } else {\n      synth = this.synth;\n      synth.refreshInstruments(input);\n    }\n\n    // link ready\n    w.postMessage('link,ready', '*');\n  };\n\n  /**\n   * @param {Event} ev\n   */\n  onmessage(ev) {\n    /** @type {Array} */\n    const msg = typeof ev.data.split === 'function' ? ev.data.split(',') : [];\n    /** @type {string} */\n    const type = msg !== [] ? msg.shift() : '';\n    /** @type {Window} */\n    const opener = window.opener ? window.opener : window.parent;\n    /** @type {string} */\n    let command;\n\n    switch (type) {\n      case 'midi':\n        this.processMidiMessage(msg.map((hex) => {\n          return parseInt(hex, 16);\n        }));\n        break;\n      case 'link':\n        if (opener === void 0) {\n          return;\n        }\n        command = msg.shift();\n        switch (command) {\n          case 'reqpatch':\n            // TODO: dummy data\n            opener.postMessage('link,patch', '*');\n            break;\n          case 'setpatch':\n          case 'ready':\n            opener.postMessage('link,ready', '*');\n            // TODO: NOP\n            break;\n          case 'progress':\n            opener.postMessage('link,progress', '*');\n            break;\n          default:\n            console.error('unknown link message:', command);\n            break;\n        }\n        break;\n      default:\n      // console.error('unknown message type');\n    }\n  };\n\n  /**\n   * @param {function(ArrayBuffer)} callback\n   * @export\n   */\n  setLoadCallback(callback) {\n    this.loadCallback = callback;\n  };\n\n  /**\n   * @param {Array.<number>} message\n   */\n  processMidiMessage(message) {\n    /** @type {number} */\n    const channel = message[0] & 0x0f;\n    /** @type {Synthesizer} */\n    const synth = this.synth;\n\n    switch (message[0] & 0xf0) {\n      case 0x80: // NoteOff: 8n kk vv\n        synth.noteOff(channel, message[1], message[2]);\n        break;\n      case 0x90: // NoteOn: 9n kk vv\n        if (message[2] > 0) {\n          synth.noteOn(channel, message[1], message[2]);\n        } else {\n          synth.noteOff(channel, message[1], 0);\n        }\n        break;\n      case 0xB0: // Control Change: Bn cc dd\n        /** @type {number} */\n        const value = message[2];\n        switch (message[1]) {\n          case 0x00: // Bank Select MSB: Bn 00 dd\n            synth.bankSelectMsb(channel, value);\n            break;\n          case 0x01: // Modulation\n            break;\n          case 0x06: // Data Entry(MSB): Bn 06 dd\n            if (this.rpnMode) {\n              // RPN\n              switch (this.RpnMsb[channel]) {\n                case 0:\n                  switch (this.RpnLsb[channel]) {\n                    case 0: // Pitch Bend Sensitivity\n                      synth.pitchBendSensitivity(channel, value);\n                      break;\n                    case 1:\n                      // console.log(\"fine\");\n                      break;\n                    case 2:\n                      // console.log(\"coarse\");\n                      break;\n                    default:\n                      // console.log(\"default\");\n                      break;\n                  }\n                  break;\n                default:\n                  // console.log(\"default:\", this.RpnMsb[channel], this.RpnLsb[channel]);\n                  break;\n              }\n            } else {\n              // NRPN\n              switch (this.NrpnMsb[channel]) {\n                case 26: // Drum Instrument Level\n                  synth.drumInstrumentLevel(this.NrpnLsb[channel], value);\n                  break;\n                default:\n                  // console.log(\"default:\", this.RpnMsb[channel], this.RpnLsb[channel]);\n                  break;\n              }\n            }\n            break;\n          case 0x26: // Data Entry(LSB): Bn 26 dd\n            if (this.rpnMode) {\n              // RPN\n              switch (this.RpnMsb[channel]) {\n                case 0:\n                  switch (this.RpnLsb[channel]) {\n                    case 0: // Pitch Bend Sensitivity\n                      synth.pitchBendSensitivity(\n                        channel,\n                        synth.getPitchBendSensitivity(channel) + value / 100\n                      );\n                      break;\n                    case 1:\n                      // console.log(\"fine\");\n                      break;\n                    case 2:\n                      // console.log(\"coarse\");\n                      break;\n                  }\n                  break;\n              }\n            }\n            // NRPN で LSB が必要なものは今のところない\n            break;\n          case 0x07: // Volume Change: Bn 07 dd\n            synth.volumeChange(channel, value);\n            break;\n          case 0x0A: // Panpot Change: Bn 0A dd\n            synth.panpotChange(channel, value);\n            break;\n          case 0x78: // All Sound Off: Bn 78 00\n            synth.allSoundOff(channel);\n            break;\n          case 0x79: // Reset All Control: Bn 79 00\n            synth.resetAllControl(channel);\n            break;\n          case 0x20: // BankSelect LSB: Bn 00 dd\n            synth.bankSelectLsb(channel, value);\n            break;\n          case 0x47: // Harmonic Content\n            synth.harmonicContent(channel, value);\n            break;\n          case 0x60: //\n            // console.log(60);\n            break;\n          case 0x61: //\n            // console.log(61);\n            break;\n          case 0x62: // NRPN LSB\n            this.rpnMode = false;\n            this.NrpnLsb[channel] = value;\n            break;\n          case 0x63: // NRPN MSB\n            this.rpnMode = false;\n            this.NrpnMsb[channel] = value;\n            break;\n          case 0x64: // RPN LSB\n            this.rpnMode = true;\n            this.RpnLsb[channel] = value;\n            break;\n          case 0x65: // RPN MSB\n            this.rpnMode = true;\n            this.RpnMsb[channel] = value;\n            break;\n          case 0x40: // Hold\n            synth.hold(channel, value);\n            break;\n          case 0x0b: // Expression\n            synth.expression(channel, value);\n            break;\n          case 0x48: // DecayTyme\n            synth.decayTime(channel, value);\n            break;\n          case 0x49: // ReleaseTime\n            synth.releaseTime(channel, value);\n            break;\n          case 0x4A: // Attack time\n            synth.attackTime(channel, value);\n            break;\n          case 0x4B: // Brightness\n            synth.cutOffFrequency(channel, value);\n            break;\n          case 0x5B: // Effect1 Depth（Reverb Send Level）\n            synth.reverbDepth(channel, value);\n            break;\n          default:\n            // not supported\n            break;\n        }\n        break;\n      case 0xC0: // Program Change: Cn pp\n        synth.programChange(channel, message[1]);\n        break;\n      case 0xE0: // Pitch Bend\n        synth.pitchBend(channel, message[1], message[2]);\n        break;\n      case 0xf0: // System Exclusive Message\n        // ID number\n        switch (message[1]) {\n          case 0x7e: // non-realtime\n            // TODO\n            // GM Reset: F0 7E 7F 09 01 F7\n            if (message[2] === 0x7f && message[3] === 0x09 && message[4] === 0x01) {\n              synth.init('GM');\n            }\n            break;\n          case 0x7f: // realtime\n            // sub ID 1\n            switch (message[3]) {\n              case 0x04: // device control\n                // sub ID 2\n                switch (message[4]) {\n                  case 0x01: // master volume: F0 7F 7F 04 01 [value] [value] F7\n                    synth.setMasterVolume(message[5] + (message[6] << 7));\n                    break;\n                }\n                break;\n            }\n            break;\n        }\n\n        // Vendor\n        switch (message[2]) {\n          case 0x43: // Yamaha XG\n            if (message[5] === 0x08) {\n              // XG Dram Part: F0 43 [dev] 4C 08 [partNum] 07 [map] F7\n              // but there is no file to use much this parameter...\n              if (message[7] !== 0x00) { // [map]\n                synth.setPercussionPart(message[6], true);\n              } else {\n                synth.setPercussionPart(message[6], false);\n              }\n              // console.log(message);\n            }\n            switch (message[7]) {\n              case 0x04:\n                // XG Master Volume: F0 43 [dev] 4C 00 00 04 [value] F7\n                synth.setMasterVolume((message[8] << 7) * 2);\n                // console.log(message[8] << 7);\n                break;\n              case 0x7E:\n                // XG Reset: F0 43 [dev] 4C 00 00 7E 00 F7\n                synth.init('XG');\n                console.log('XG Reset');\n                break;\n            }\n            break;\n          case 0x41: // Roland GS / TG300B Mode\n            // TODO\n            switch (message[8]) {\n              case 0x04:\n                // GS Master Volume: F0 41 [dev] 42 12 40 00 04 [value] 58 F7\n                synth.setMasterVolume(message[9] << 7);\n                break;\n              case 0x7F:\n                // GS Reset: F0 41 [dev] 42 12 40 00 7F 00 41 F7\n                synth.init('GS');\n                console.log('GS Reset');\n                break;\n              case 0x15:\n                // GS Dram part: F0 41 [dev] 42 12 40 1[part no] [Map] [sum] F7\n                // Notice: [sum] is ignroe in this program.\n                // http://www.ssw.co.jp/dtm/drums/drsetup.htm\n                // http://www.roland.co.jp/support/by_product/sd-20/knowledge_base/1826700/\n\n                const part = message[7] - 0x0F;\n                const map = message[8];\n                if (part === 0) {\n                  // 10 Ch.\n                  if (map !== 0x00) {\n                    synth.setPercussionPart(9, true);\n                  } else {\n                    synth.setPercussionPart(9, false);\n                  }\n                } else if (part >= 10) {\n                  // 1~9 Ch.\n                  if (map !== 0x00) {\n                    synth.setPercussionPart(part - 1, true);\n                  } else {\n                    synth.setPercussionPart(part - 1, false);\n                  }\n                } else {\n                  // 11~16 Ch.\n                  if (map !== 0x00) {\n                    synth.setPercussionPart(part, true);\n                  } else {\n                    synth.setPercussionPart(part, false);\n                  }\n                }\n                break;\n            }\n            break;\n        }\n        break;\n      default: // not supported\n        synth.setPercussionPart(9, true);\n        break;\n    }\n  };\n}\n\nexport default WebMidiLink;\n"],"sourceRoot":""}