{"version":3,"file":"index.bundled.js","sources":["index.js"],"sourcesContent":["import Reverb from '@logue/reverb';\n\n/**\n * SynthesizerNote Class\n * @private\n */\nclass SynthesizerNote {\n  /**\n   * @param {AudioContext} ctx\n   * @param {AudioNode} destination\n   * @param {{\n   *   channel: number,\n   *   key: number,\n   *   sample: Uint8Array,\n   *   basePlaybackRate: number,\n   *   loopStart: number,\n   *   loopEnd: number,\n   *   volume: number,\n   *   panpot: number\n   * }} instrument\n   */\n  constructor(ctx, destination, instrument) {\n    /** @type {AudioContext} */\n    this.ctx = ctx;\n    /** @type {AudioNode} */\n\n    this.destination = destination;\n    /** @type {{\n     *   channel: number,\n     *   key: number,\n     *   sample: Uint8Array,\n     *   basePlaybackRate: number,\n     *   loopStart: number,\n     *   loopEnd: number,\n     *   volume: number,\n     *   panpot: number\n     * }}\n     */\n\n    this.instrument = instrument;\n    /** @type {number} */\n\n    this.channel = instrument['channel'];\n    /** @type {number} */\n\n    this.key = instrument['key'];\n    /** @type {number} */\n\n    this.velocity = instrument['velocity'];\n    /** @type {Int16Array} */\n\n    this.buffer = instrument['sample'];\n    /** @type {number} */\n\n    this.playbackRate = instrument['basePlaybackRate'];\n    /** @type {number} */\n\n    this.loopStart = instrument['loopStart'];\n    /** @type {number} */\n\n    this.loopEnd = instrument['loopEnd'];\n    /** @type {number} */\n\n    this.sampleRate = instrument['sampleRate'];\n    /** @type {number} */\n\n    this.volume = instrument['volume'];\n    /** @type {number} */\n\n    this.panpot = instrument['panpot'];\n    /** @type {number} */\n\n    this.pitchBend = instrument['pitchBend'];\n    /** @type {number} */\n\n    this.pitchBendSensitivity = instrument['pitchBendSensitivity'];\n    /** @type {number} */\n\n    this.modEnvToPitch = instrument['modEnvToPitch'];\n    /** @type {number} */\n\n    this.expression = instrument['expression'];\n    /** @type {number} */\n\n    this.cutOffFrequency = instrument['cutOffFrequency'];\n    /** @type {number} */\n\n    this.hermonicContent = instrument['hermonicContent'];\n    /** @type {Reverb} */\n\n    this.reverb = instrument['reverb']; // state\n\n    /** @type {number} */\n\n    this.startTime = ctx.currentTime;\n    /** @type {number} */\n\n    this.computedPlaybackRate = this.playbackRate | 0;\n    /** @type {boolean} */\n\n    this.noteOffState = false; // ---------------------------------------------------------------------------\n    // audio node\n    // ---------------------------------------------------------------------------\n\n    /** @type {AudioBuffer} */\n\n    this.audioBuffer;\n    /** @type {AudioBufferSourceNode} */\n\n    this.bufferSource = ctx.createBufferSource();\n    /** @type {StereoPannerNode} */\n\n    this.panner = ctx.createPanner();\n    /** @type {GainNode} */\n\n    this.outputGainNode = ctx.createGain();\n    /** @type {GainNode} */\n\n    this.expressionGainNode = ctx.createGain();\n    /** @type {BiquadFilterNode} */\n\n    this.filter = ctx.createBiquadFilter();\n    /** @type {BiquadFilterNode} */\n\n    this.modulator = ctx.createBiquadFilter();\n  }\n  /**\n   */\n\n\n  noteOn() {\n    /** @type {AudioContext} */\n    const ctx = this.ctx;\n    /** @type {{\n     *   channel: number,\n     *   key: number,\n     *   sample: Uint8Array,\n     *   basePlaybackRate: number,\n     *   loopStart: number,\n     *   loopEnd: number,\n     *   volume: number,\n     *   panpot: number\n     * }} */\n\n    const instrument = this.instrument; // console.log(instrument);\n\n    /** @type {number} */\n\n    const now = this.ctx.currentTime || 0;\n    /** @type {number} */\n\n    const volDelay = now + instrument['volDelay'];\n    /** @type {number} */\n\n    const modDelay = now + instrument['modDelay'];\n    /** @type {number} */\n\n    const volAttack = volDelay + instrument['volAttack'];\n    /** @type {number} */\n\n    const modAttack = volDelay + instrument['modAttack'];\n    /** @type {number} */\n\n    const volHold = volAttack + instrument['volHold'];\n    /** @type {number} */\n\n    const modHold = modAttack + instrument['modHold'];\n    /** @type {number} */\n\n    const volDecay = volHold + instrument['volDecay'];\n    /** @type {number} */\n\n    const modDecay = modHold + instrument['modDecay'];\n    /** @type {number} */\n\n    const loopStart = instrument['loopStart'] / this.sampleRate;\n    /** @type {number} */\n\n    const loopEnd = instrument['loopEnd'] / this.sampleRate;\n    /** @type {number} */\n\n    const startTime = instrument['start'] / this.sampleRate; // TODO: ドラムパートのPanが変化した場合、その計算をしなければならない\n    // http://cpansearch.perl.org/src/PJB/MIDI-SoundFont-1.08/doc/sfspec21.html#8.4.6\n\n    /** @type {number} */\n\n    const pan = instrument['pan'] !== void 0 ? instrument['pan'] : this.panpot;\n    const sample = this.buffer.subarray(0, this.buffer.length + instrument['end']);\n    /** @type {AudioBuffer} */\n\n    const buffer = this.audioBuffer = ctx.createBuffer(1, sample.length, this.sampleRate);\n    /** @type {Float32Array} */\n\n    const channelData = buffer.getChannelData(0);\n    channelData.set(sample); // buffer source\n\n    /** @type {AudioBufferSourceNode} */\n\n    const bufferSource = this.bufferSource;\n    bufferSource.buffer = buffer;\n    bufferSource.loop = instrument['sampleModes'] | 0 || 0;\n    bufferSource.loopStart = loopStart;\n    bufferSource.loopEnd = loopEnd;\n    this.updatePitchBend(this.pitchBend); // Output\n\n    /** @type {GainNode} */\n\n    const output = this.outputGainNode; // expression\n\n    this.expressionGainNode.gain.value = this.expression / 127; // panpot\n\n    /** @type {StereoPannerNode} */\n\n    const panner = this.panner;\n    panner.panningModel = 'equalpower'; // panner.distanceModel = 'inverse';\n\n    panner.setPosition(Math.sin(pan * Math.PI / 2), 0, Math.cos(pan * Math.PI / 2)); // ---------------------------------------------------------------------------\n    // Delay, Attack, Hold, Decay, Sustain\n    // ---------------------------------------------------------------------------\n\n    /** @type {number} */\n\n    let volume = this.volume * (this.velocity / 127) * (1 - instrument['initialAttenuation'] / 1000);\n\n    if (volume < 0) {\n      volume = 0;\n    } // volume envelope\n\n    /** @type {AudioNode} */\n\n\n    const outputGain = output.gain;\n    outputGain.setValueAtTime(0, now);\n    outputGain.setValueAtTime(0, volDelay);\n    outputGain.setTargetAtTime(volume, volDelay, instrument['volAttack']);\n    outputGain.setValueAtTime(volume, volHold);\n    outputGain.linearRampToValueAtTime(volume * (1 - instrument['volSustain']), volDecay); // modulation envelope\n\n    /** @type {number} */\n\n    const baseFreq = this.amountToFreq(instrument['initialFilterFc']);\n    /** @type {number} */\n\n    const peekFreq = this.amountToFreq(instrument['initialFilterFc'] + instrument['modEnvToFilterFc']);\n    /** @type {number} */\n\n    const sustainFreq = baseFreq + (peekFreq - baseFreq) * (1 - instrument['modSustain']);\n    /** @type {BiquadFilterNode} */\n\n    const modulator = this.modulator;\n    modulator.Q.setValueAtTime(10 ** (instrument['initialFilterQ'] / 200), now);\n    modulator.frequency.value = baseFreq;\n    modulator.type = 'lowpass';\n    modulator.frequency.setTargetAtTime(baseFreq / 127, this.ctx.currentTime, 0.5);\n    modulator.frequency.setValueAtTime(baseFreq, now);\n    modulator.frequency.setValueAtTime(baseFreq, modDelay);\n    modulator.frequency.setTargetAtTime(peekFreq, modDelay, parseFloat(instrument['modAttack'] + 1)); // For FireFox fix\n\n    modulator.frequency.setValueAtTime(peekFreq, modHold);\n    modulator.frequency.linearRampToValueAtTime(sustainFreq, modDecay); // connect\n\n    bufferSource.connect(modulator);\n    modulator.connect(panner);\n    panner.connect(this.expressionGainNode);\n    this.expressionGainNode.connect(output);\n\n    if (!instrument['mute']) {\n      this.connect();\n    } // fire\n\n\n    bufferSource.start(0, startTime);\n  }\n  /**\n   * @param {number} val\n   * @return {number}\n   */\n\n\n  amountToFreq(val) {\n    return 2 ** ((val - 6900) / 1200) * 440;\n  }\n  /**\n   */\n\n\n  noteOff() {\n    this.noteOffState = true;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  isNoteOff() {\n    return this.noteOffState;\n  }\n  /**\n   * @return {void}\n   */\n\n\n  release() {\n    /** @type {{\n     *   channel: number,\n     *   key: number,\n     *   sample: Uint8Array,\n     *   basePlaybackRate: number,\n     *   loopStart: number,\n     *   loopEnd: number,\n     *   volume: number,\n     *   panpot: number\n     * }} */\n    const instrument = this.instrument;\n    /** @type {AudioBufferSourceNode} */\n\n    const bufferSource = this.bufferSource;\n    /** @type {GainNode} */\n\n    const output = this.outputGainNode;\n    /** @type {number} */\n\n    const now = this.ctx.currentTime;\n    const release = instrument['releaseTime'] - 64; // ---------------------------------------------------------------------------\n    // volume release time\n    // ---------------------------------------------------------------------------\n\n    /** @type {number} */\n\n    const volEndTimeTmp = instrument['volRelease'] * output.gain.value;\n    /** @type {number} */\n\n    const volEndTime = now + volEndTimeTmp * (1 + release / (release < 0 ? 64 : 63)); // var volEndTime = now + instrument['volRelease'] * (1 - instrument['volSustain']);\n    // ---------------------------------------------------------------------------\n    // modulation release time\n    // ---------------------------------------------------------------------------\n\n    /** @type {BiquadFilterNode} */\n\n    const modulator = this.modulator;\n    /** @type {number} */\n\n    const baseFreq = this.amountToFreq(instrument['initialFilterFc']);\n    /** @type {number} */\n\n    const peekFreq = this.amountToFreq(instrument['initialFilterFc'] + instrument['modEnvToFilterFc']);\n    /** @type {number} */\n\n    const modEndTime = now + instrument['modRelease'] * (baseFreq === peekFreq ? 1 : (modulator.frequency.value - baseFreq) / (peekFreq - baseFreq)); // var modEndTime = now + instrument['modRelease'] * (1 - instrument['modSustain']);\n\n    if (!this.audioBuffer) {\n      return;\n    } // ---------------------------------------------------------------------------\n    // Release\n    // ---------------------------------------------------------------------------\n\n\n    switch (instrument['sampleModes']) {\n      case 0:\n        // ループしない\n        bufferSource.loop = false;\n        bufferSource.disconnect();\n        bufferSource.buffer = null;\n        break;\n\n      case 1:\n        // ループさせる\n        output.gain.cancelScheduledValues(0);\n        output.gain.setValueAtTime(output.gain.value, now);\n        output.gain.linearRampToValueAtTime(0, volEndTime);\n        modulator.frequency.cancelScheduledValues(0);\n        modulator.frequency.setValueAtTime(modulator.frequency.value, now);\n        modulator.frequency.linearRampToValueAtTime(baseFreq, modEndTime);\n        bufferSource.playbackRate.cancelScheduledValues(0);\n        bufferSource.playbackRate.setValueAtTime(bufferSource.playbackRate.value, now);\n        bufferSource.playbackRate.linearRampToValueAtTime(this.computedPlaybackRate, modEndTime);\n        bufferSource.stop(volEndTime);\n        break;\n\n      case 2:\n        // 未定義\n        console.error('detect unused sampleModes');\n        break;\n\n      case 3:\n        // ノートオフまでループさせる\n        output.gain.cancelScheduledValues(0);\n        output.gain.setValueAtTime(output.gain.value, now);\n        output.gain.linearRampToValueAtTime(0, volEndTime);\n        modulator.frequency.cancelScheduledValues(0);\n        modulator.frequency.setValueAtTime(modulator.frequency.value, now);\n        modulator.frequency.linearRampToValueAtTime(baseFreq, modEndTime);\n        bufferSource.playbackRate.cancelScheduledValues(0);\n        bufferSource.playbackRate.setValueAtTime(bufferSource.playbackRate.value, now);\n        bufferSource.playbackRate.linearRampToValueAtTime(this.computedPlaybackRate, modEndTime);\n\n      default:\n        bufferSource.loop = false;\n        break;\n    }\n  }\n  /**\n   */\n\n\n  connect() {\n    this.reverb.connect(this.outputGainNode).connect(this.destination);\n  }\n  /**\n   */\n\n\n  disconnect() {\n    this.outputGainNode.disconnect(0);\n  }\n  /**\n   */\n\n\n  schedulePlaybackRate() {\n    const playbackRate = this.bufferSource.playbackRate;\n    /** @type {number} */\n\n    const computed = this.computedPlaybackRate;\n    /** @type {number} */\n\n    const start = this.startTime;\n    /** @type {Object} */\n\n    const instrument = this.instrument;\n    /** @type {number} */\n\n    const modAttack = start + instrument['modAttack'];\n    /** @type {number} */\n\n    const modDecay = modAttack + instrument['modDecay'];\n    /** @type {number} */\n\n    const peekPitch = computed * 1.0594630943592953 // Math.pow(2, 1 / 12)\n    ** (this.modEnvToPitch * this.instrument['scaleTuning']);\n    playbackRate.cancelScheduledValues(0);\n    playbackRate.setValueAtTime(computed, start);\n    playbackRate.linearRampToValueAtTime(peekPitch, modAttack);\n    playbackRate.linearRampToValueAtTime(computed + (peekPitch - computed) * (1 - instrument['modSustain']), modDecay);\n  }\n  /**\n   * @param {number} expression\n   */\n\n\n  updateExpression(expression) {\n    this.expressionGainNode.gain.value = (this.expression = expression) / 127;\n  }\n  /**\n   * @param {number} pitchBend\n   */\n\n\n  updatePitchBend(pitchBend) {\n    this.computedPlaybackRate = this.playbackRate * 1.0594630943592953 // Math.pow(2, 1 / 12)\n    ** (pitchBend / (pitchBend < 0 ? 8192 : 8191) * this.pitchBendSensitivity * this.instrument['scaleTuning']);\n    this.schedulePlaybackRate();\n  }\n\n}\n\n/**\n * Riff Parser class\n * @private\n */\nclass Riff {\n  /**\n   * @param {ByteArray} input input buffer.\n   * @param {Object=} optParams option parameters.\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {number} */\n\n    this.ip = optParams.index || 0;\n    /** @type {number} */\n\n    this.length = optParams.length || input.length - this.ip;\n    /** @type {Array.<RiffChunk>} */\n\n    this.chunkList;\n    /** @type {number} */\n\n    this.offset = this.ip;\n    /** @type {boolean} */\n\n    this.padding = optParams.padding !== void 0 ? optParams.padding : true;\n    /** @type {boolean} */\n\n    this.bigEndian = optParams.bigEndian !== void 0 ? optParams.bigEndian : false;\n  }\n  /**\n   */\n\n\n  parse() {\n    /** @type {number} */\n    const length = this.length + this.offset;\n    this.chunkList = [];\n\n    while (this.ip < length) {\n      this.parseChunk();\n    }\n  }\n  /**\n   */\n\n\n  parseChunk() {\n    /** @type {ByteArray} */\n    const input = this.input;\n    /** @type {number} */\n\n    let ip = this.ip;\n    /** @type {number} */\n\n    let size;\n    this.chunkList.push(new RiffChunk(String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]), size = this.bigEndian ? (input[ip++] << 24 | input[ip++] << 16 | input[ip++] << 8 | input[ip++]) >>> 0 : (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0, ip));\n    ip += size; // padding\n\n    if (this.padding && (ip - this.offset & 1) === 1) {\n      ip++;\n    }\n\n    this.ip = ip;\n  }\n  /**\n   * @param {number} index chunk index.\n   * @return {?RiffChunk}\n   */\n\n\n  getChunk(index) {\n    /** @type {RiffChunk} */\n    const chunk = this.chunkList[index];\n\n    if (chunk === void 0) {\n      return null;\n    }\n\n    return chunk;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  getNumberOfChunks() {\n    return this.chunkList.length;\n  }\n\n}\n/**\n * Riff Chunk Structure\n * @interface\n */\n\nclass RiffChunk {\n  /**\n   * @param {string} type\n   * @param {number} size\n   * @param {number} offset\n   */\n  constructor(type, size, offset) {\n    /** @type {string} */\n    this.type = type;\n    /** @type {number} */\n\n    this.size = size;\n    /** @type {number} */\n\n    this.offset = offset;\n  }\n\n}\n\n/**\n * SoundFont Parser Class\n */\n\nclass Parser {\n  /**\n   * @param {ByteArray} input\n   * @param {Object=} optParams\n   */\n  constructor(input, optParams = {}) {\n    /** @type {ByteArray} */\n    this.input = input;\n    /** @type {(Object|undefined)} */\n\n    this.parserOption = optParams.parserOption || {};\n    /** @type {(Number|undefined)} */\n\n    this.sampleRate = optParams.sampleRate || 22050; // よくわからんが、OSで指定されているサンプルレートを入れないと音が切れ切れになる。\n\n    /** @type {Array.<Object>} */\n\n    this.presetHeader;\n    /** @type {Array.<Object>} */\n\n    this.presetZone;\n    /** @type {Array.<Object>} */\n\n    this.presetZoneModulator;\n    /** @type {Array.<Object>} */\n\n    this.presetZoneGenerator;\n    /** @type {Array.<Object>} */\n\n    this.instrument;\n    /** @type {Array.<Object>} */\n\n    this.instrumentZone;\n    /** @type {Array.<Object>} */\n\n    this.instrumentZoneModulator;\n    /** @type {Array.<Object>} */\n\n    this.instrumentZoneGenerator;\n    /** @type {Array.<Object>} */\n\n    this.sampleHeader;\n    /**\n     * @type {Array.<string>}\n     * @const\n     */\n\n    this.GeneratorEnumeratorTable = ['startAddrsOffset', 'endAddrsOffset', 'startloopAddrsOffset', 'endloopAddrsOffset', 'startAddrsCoarseOffset', 'modLfoToPitch', 'vibLfoToPitch', 'modEnvToPitch', 'initialFilterFc', 'initialFilterQ', 'modLfoToFilterFc', 'modEnvToFilterFc', 'endAddrsCoarseOffset', 'modLfoToVolume',, // 14\n    'chorusEffectsSend', 'reverbEffectsSend', 'pan',,,, // 18,19,20\n    'delayModLFO', 'freqModLFO', 'delayVibLFO', 'freqVibLFO', 'delayModEnv', 'attackModEnv', 'holdModEnv', 'decayModEnv', 'sustainModEnv', 'releaseModEnv', 'keynumToModEnvHold', 'keynumToModEnvDecay', 'delayVolEnv', 'attackVolEnv', 'holdVolEnv', 'decayVolEnv', 'sustainVolEnv', 'releaseVolEnv', 'keynumToVolEnvHold', 'keynumToVolEnvDecay', 'instrument',, // 42\n    'keyRange', 'velRange', 'startloopAddrsCoarseOffset', 'keynum', 'velocity', 'initialAttenuation',, // 49\n    'endloopAddrsCoarseOffset', 'coarseTune', 'fineTune', 'sampleID', 'sampleModes',, // 55\n    'scaleTuning', 'exclusiveClass', 'overridingRootKey', // 59\n    'endOper'];\n  }\n  /** @export */\n\n\n  parse() {\n    /** @type {Riff} */\n    const parser = new Riff(this.input, this.parserOption); // parse RIFF chunk\n\n    parser.parse();\n\n    if (parser.chunkList.length !== 1) {\n      throw new Error('wrong chunk length');\n    }\n    /** @type {?RiffChunk} */\n\n\n    const chunk = parser.getChunk(0);\n\n    if (chunk === null) {\n      throw new Error('chunk not found');\n    }\n\n    this.parseRiffChunk(chunk); // console.log(this.sampleHeader);\n\n    this.input = null;\n  }\n  /**\n   * @param {RiffChunk} chunk\n   */\n\n\n  parseRiffChunk(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset; // check parse target\n\n    if (chunk.type !== 'RIFF') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    } // check signature\n\n    /** @type {string} */\n\n\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n\n    if (signature !== 'sfbk') {\n      throw new Error('invalid signature:' + signature);\n    } // read structure\n\n    /** @type {Riff} */\n\n\n    const parser = new Riff(data, {\n      'index': ip,\n      'length': chunk.size - 4\n    });\n    parser.parse();\n\n    if (parser.getNumberOfChunks() !== 3) {\n      throw new Error('invalid sfbk structure');\n    } // INFO-list\n\n\n    this.parseInfoList(\n    /** @type {!RiffChunk} */\n    parser.getChunk(0)); // sdta-list\n\n    this.parseSdtaList(\n    /** @type {!RiffChunk} */\n    parser.getChunk(1)); // pdta-list\n\n    this.parsePdtaList(\n    /** @type {!RiffChunk} */\n    parser.getChunk(2));\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseInfoList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset; // check parse target\n\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    } // check signature\n\n    /** @type {string} */\n\n\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n\n    if (signature !== 'INFO') {\n      throw new Error('invalid signature:' + signature);\n    } // read structure\n\n    /** @type {Riff} */\n\n\n    const parser = new Riff(data, {\n      'index': ip,\n      'length': chunk.size - 4\n    });\n    parser.parse();\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseSdtaList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset; // check parse target\n\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    } // check signature\n\n    /** @type {string} */\n\n\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n\n    if (signature !== 'sdta') {\n      throw new Error('invalid signature:' + signature);\n    } // read structure\n\n    /** @type {Riff} */\n\n\n    const parser = new Riff(data, {\n      'index': ip,\n      'length': chunk.size - 4\n    });\n    parser.parse();\n\n    if (parser.chunkList.length !== 1) {\n      throw new Error('TODO');\n    }\n\n    this.samplingData =\n    /** @type {{type: string, size: number, offset: number}} */\n    parser.getChunk(0);\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePdtaList(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset; // check parse target\n\n    if (chunk.type !== 'LIST') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    } // check signature\n\n    /** @type {string} */\n\n\n    const signature = String.fromCharCode(data[ip++], data[ip++], data[ip++], data[ip++]);\n\n    if (signature !== 'pdta') {\n      throw new Error('invalid signature:' + signature);\n    } // read structure\n\n    /** @type {Riff} */\n\n\n    const parser = new Riff(data, {\n      'index': ip,\n      'length': chunk.size - 4\n    });\n    parser.parse(); // check number of chunks\n\n    if (parser.getNumberOfChunks() !== 9) {\n      throw new Error('invalid pdta chunk');\n    }\n\n    this.parsePhdr(\n    /** @type {RiffChunk} */\n    parser.getChunk(0));\n    this.parsePbag(\n    /** @type {RiffChunk} */\n    parser.getChunk(1));\n    this.parsePmod(\n    /** @type {RiffChunk} */\n    parser.getChunk(2));\n    this.parsePgen(\n    /** @type {RiffChunk} */\n    parser.getChunk(3));\n    this.parseInst(\n    /** @type {RiffChunk} */\n    parser.getChunk(4));\n    this.parseIbag(\n    /** @type {RiffChunk} */\n    parser.getChunk(5));\n    this.parseImod(\n    /** @type {RiffChunk} */\n    parser.getChunk(6));\n    this.parseIgen(\n    /** @type {RiffChunk} */\n    parser.getChunk(7));\n    this.parseShdr(\n    /** @type {RiffChunk} */\n    parser.getChunk(8));\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePhdr(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n\n    const presetHeader = this.presetHeader = [];\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size; // check parse target\n\n    if (chunk.type !== 'phdr') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      presetHeader.push({\n        presetName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),\n        preset: data[ip++] | data[ip++] << 8,\n        bank: data[ip++] | data[ip++] << 8,\n        presetBagIndex: data[ip++] | data[ip++] << 8,\n        library: (data[ip++] | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0,\n        genre: (data[ip++] | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0,\n        morphology: (data[ip++] | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0\n      });\n    }\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePbag(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n\n    const presetZone = this.presetZone = [];\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size; // check parse target\n\n    if (chunk.type !== 'pbag') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      presetZone.push({\n        presetGeneratorIndex: data[ip++] | data[ip++] << 8,\n        presetModulatorIndex: data[ip++] | data[ip++] << 8\n      });\n    }\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePmod(chunk) {\n    // check parse target\n    if (chunk.type !== 'pmod') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.presetZoneModulator = this.parseModulator(chunk);\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parsePgen(chunk) {\n    // check parse target\n    if (chunk.type !== 'pgen') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.presetZoneGenerator = this.parseGenerator(chunk);\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseInst(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n\n    const instrument = this.instrument = [];\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size; // check parse target\n\n    if (chunk.type !== 'inst') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      instrument.push({\n        instrumentName: String.fromCharCode.apply(null, data.subarray(ip, ip += 20)),\n        instrumentBagIndex: data[ip++] | data[ip++] << 8\n      });\n    }\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseIbag(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n\n    const instrumentZone = this.instrumentZone = [];\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size; // check parse target\n\n    if (chunk.type !== 'ibag') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      instrumentZone.push({\n        instrumentGeneratorIndex: data[ip++] | data[ip++] << 8,\n        instrumentModulatorIndex: data[ip++] | data[ip++] << 8\n      });\n    }\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseImod(chunk) {\n    // check parse target\n    if (chunk.type !== 'imod') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.instrumentZoneModulator = this.parseModulator(chunk);\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseIgen(chunk) {\n    // check parse target\n    if (chunk.type !== 'igen') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    this.instrumentZoneGenerator = this.parseGenerator(chunk);\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   */\n  parseShdr(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {Array.<Object>} */\n\n    const samples = this.sample = [];\n    /** @type {Array.<Object>} */\n\n    const sampleHeader = this.sampleHeader = [];\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size;\n    /** @type {string} */\n\n    let sampleName;\n    /** @type {number} */\n\n    let start;\n    /** @type {number} */\n\n    let end;\n    /** @type {number} */\n\n    let startLoop;\n    /** @type {number} */\n\n    let endLoop;\n    /** @type {number} */\n\n    let sampleRate;\n    /** @type {number} */\n\n    let originalPitch;\n    /** @type {number} */\n\n    let pitchCorrection;\n    /** @type {number} */\n\n    let sampleLink;\n    /** @type {number} */\n\n    let sampleType; // check parse target\n\n    if (chunk.type !== 'shdr') {\n      throw new Error('invalid chunk type:' + chunk.type);\n    }\n\n    while (ip < size) {\n      sampleName = String.fromCharCode.apply(null, data.subarray(ip, ip += 20));\n      start = (data[ip++] << 0 | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0;\n      end = (data[ip++] << 0 | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0;\n      startLoop = (data[ip++] << 0 | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0;\n      endLoop = (data[ip++] << 0 | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0;\n      sampleRate = (data[ip++] << 0 | data[ip++] << 8 | data[ip++] << 16 | data[ip++] << 24) >>> 0;\n      originalPitch = data[ip++];\n      pitchCorrection = data[ip++] << 24 >> 24;\n      sampleLink = data[ip++] | data[ip++] << 8;\n      sampleType = data[ip++] | data[ip++] << 8;\n      let sample = new Int16Array(new Uint8Array(data.subarray(this.samplingData.offset + start * 2, this.samplingData.offset + end * 2)).buffer);\n      startLoop -= start;\n      endLoop -= start;\n\n      if (sampleRate > 0) {\n        const adjust = this.adjustSampleData(sample, sampleRate);\n        sample = adjust.sample;\n        sampleRate *= adjust.multiply;\n        startLoop *= adjust.multiply;\n        endLoop *= adjust.multiply;\n      }\n\n      samples.push(sample);\n      sampleHeader.push({\n        sampleName: sampleName,\n        start: start,\n        end: end,\n        startLoop: startLoop,\n        endLoop: endLoop,\n        sampleRate: sampleRate,\n        originalPitch: originalPitch,\n        pitchCorrection: pitchCorrection,\n        sampleLink: sampleLink,\n        sampleType: sampleType\n      });\n    }\n  }\n\n  /**\n   * @param {Array} sample\n   * @param {number} sampleRate\n   * @return {object}\n   */\n  adjustSampleData(sample, sampleRate) {\n    /** @type {Int16Array} */\n    let newSample;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {number} */\n\n    let j;\n    /** @type {number} */\n\n    let multiply = 1; // buffer\n\n    while (sampleRate < this.sampleRate) {\n      // AudioContextのサンプルレートに変更\n      newSample = new Int16Array(sample.length * 2);\n\n      for (i = j = 0, il = sample.length; i < il; ++i) {\n        newSample[j++] = sample[i];\n        newSample[j++] = sample[i];\n      }\n\n      sample = newSample;\n      multiply *= 2;\n      sampleRate *= 2;\n    }\n\n    return {\n      sample: sample,\n      multiply: multiply\n    };\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   * @return {Array.<Object>}\n   */\n  parseModulator(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size;\n    /** @type {number} */\n\n    let code;\n    /** @type {string} */\n\n    let key;\n    /** @type {Array.<Object>} */\n\n    const output = [];\n\n    while (ip < size) {\n      // Src  Oper\n      // TODO\n      ip += 2; // Dest Oper\n\n      code = data[ip++] | data[ip++] << 8;\n      key = this.GeneratorEnumeratorTable[code];\n\n      if (key === void 0) {\n        // Amount\n        output.push({\n          type: key,\n          value: {\n            code: code,\n            amount: data[ip] | data[ip + 1] << 8 << 16 >> 16,\n            lo: data[ip++],\n            hi: data[ip++]\n          }\n        });\n      } else {\n        // Amount\n        switch (key) {\n          case 'keyRange':\n          /* FALLTHROUGH */\n\n          case 'velRange':\n          /* FALLTHROUGH */\n\n          case 'keynum':\n          /* FALLTHROUGH */\n\n          case 'velocity':\n            output.push({\n              type: key,\n              value: {\n                lo: data[ip++],\n                hi: data[ip++]\n              }\n            });\n            break;\n\n          default:\n            output.push({\n              type: key,\n              value: {\n                amount: data[ip++] | data[ip++] << 8 << 16 >> 16\n              }\n            });\n            break;\n        }\n      } // AmtSrcOper\n      // TODO\n\n\n      ip += 2; // Trans Oper\n      // TODO\n\n      ip += 2;\n    }\n\n    return output;\n  }\n\n  /**\n   * @param {RiffChunk} chunk\n   * @return {Array.<Object>}\n   */\n  parseGenerator(chunk) {\n    /** @type {ByteArray} */\n    const data = this.input;\n    /** @type {number} */\n\n    let ip = chunk.offset;\n    /** @type {number} */\n\n    const size = chunk.offset + chunk.size;\n    /** @type {number} */\n\n    let code;\n    /** @type {string} */\n\n    let key;\n    /** @type {Array.<Object>} */\n\n    const output = [];\n\n    while (ip < size) {\n      code = data[ip++] | data[ip++] << 8;\n      key = this.GeneratorEnumeratorTable[code];\n\n      if (key === void 0) {\n        output.push({\n          type: key,\n          value: {\n            code: code,\n            amount: data[ip] | data[ip + 1] << 8 << 16 >> 16,\n            lo: data[ip++],\n            hi: data[ip++]\n          }\n        });\n        continue;\n      }\n\n      switch (key) {\n        case 'keynum':\n        /* FALLTHROUGH */\n\n        case 'keyRange':\n        /* FALLTHROUGH */\n\n        case 'velRange':\n        /* FALLTHROUGH */\n\n        case 'velocity':\n          output.push({\n            type: key,\n            value: {\n              lo: data[ip++],\n              hi: data[ip++]\n            }\n          });\n          break;\n\n        default:\n          output.push({\n            type: key,\n            value: {\n              amount: data[ip++] | data[ip++] << 8 << 16 >> 16\n            }\n          });\n          break;\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * @return {Array.<object>}\n   */\n  createInstrument() {\n    /** @type {Array.<Object>} */\n    const instrument = this.instrument;\n    /** @type {Array.<Object>} */\n\n    const zone = this.instrumentZone;\n    /** @type {Array.<Object>} */\n\n    const output = [];\n    /** @type {number} */\n\n    let bagIndex;\n    /** @type {number} */\n\n    let bagIndexEnd;\n    /** @type {Array.<Object>} */\n\n    let zoneInfo;\n    /** @type {{generator: Object, generatorInfo: Array.<Object>}} */\n\n    let instrumentGenerator;\n    /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */\n\n    let instrumentModulator;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {number} */\n\n    let j;\n    /** @type {number} */\n\n    let jl; // instrument -> instrument bag -> generator / modulator\n\n    for (i = 0, il = instrument.length; i < il; ++i) {\n      bagIndex = instrument[i].instrumentBagIndex;\n      bagIndexEnd = instrument[i + 1] ? instrument[i + 1].instrumentBagIndex : zone.length;\n      zoneInfo = []; // instrument bag\n\n      for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {\n        instrumentGenerator = this.createInstrumentGenerator_(zone, j);\n        instrumentModulator = this.createInstrumentModulator_(zone, j);\n        zoneInfo.push({\n          generator: instrumentGenerator.generator,\n          generatorSequence: instrumentGenerator.generatorInfo,\n          modulator: instrumentModulator.modulator,\n          modulatorSequence: instrumentModulator.modulatorInfo\n        });\n      }\n\n      output.push({\n        name: instrument[i].instrumentName,\n        info: zoneInfo\n      });\n    }\n\n    return output;\n  }\n\n  /**\n   * @return {Array.<object>}\n   */\n  createPreset() {\n    /** @type {Array.<Object>} */\n    const preset = this.presetHeader;\n    /** @type {Array.<Object>} */\n\n    const zone = this.presetZone;\n    /** @type {Array.<Object>} */\n\n    const output = [];\n    /** @type {number} */\n\n    let bagIndex;\n    /** @type {number} */\n\n    let bagIndexEnd;\n    /** @type {Array.<Object>} */\n\n    let zoneInfo;\n    /** @type {number} */\n\n    let instrument;\n    /** @type {{generator: Object, generatorInfo: Array.<Object>}} */\n\n    let presetGenerator;\n    /** @type {{modulator: Object, modulatorInfo: Array.<Object>}} */\n\n    let presetModulator;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {number} */\n\n    let j;\n    /** @type {number} */\n\n    let jl; // preset -> preset bag -> generator / modulator\n\n    for (i = 0, il = preset.length; i < il; ++i) {\n      bagIndex = preset[i].presetBagIndex;\n      bagIndexEnd = preset[i + 1] ? preset[i + 1].presetBagIndex : zone.length;\n      zoneInfo = []; // preset bag\n\n      for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {\n        presetGenerator = this.createPresetGenerator_(zone, j);\n        presetModulator = this.createPresetModulator_(zone, j);\n        zoneInfo.push({\n          generator: presetGenerator.generator,\n          generatorSequence: presetGenerator.generatorInfo,\n          modulator: presetModulator.modulator,\n          modulatorSequence: presetModulator.modulatorInfo\n        });\n        instrument = presetGenerator.generator['instrument'] !== void 0 ? presetGenerator.generator['instrument'].amount : presetModulator.modulator['instrument'] !== void 0 ? presetModulator.modulator['instrument'].amount : null;\n      }\n\n      output.push({\n        name: preset[i].presetName,\n        info: zoneInfo,\n        header: preset[i],\n        instrument: instrument\n      });\n    }\n\n    return output;\n  }\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{generator: Object, generatorInfo: Array.<Object>}}\n   * @private\n   */\n  createInstrumentGenerator_(zone, index) {\n    const modgen = this.createBagModGen_(zone, zone[index].instrumentGeneratorIndex, zone[index + 1] ? zone[index + 1].instrumentGeneratorIndex : this.instrumentZoneGenerator.length, this.instrumentZoneGenerator);\n    return {\n      generator: modgen.modgen,\n      generatorInfo: modgen.modgenInfo\n    };\n  }\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{modulator: Object, modulatorInfo: Array.<Object>}}\n   * @private\n   */\n  createInstrumentModulator_(zone, index) {\n    const modgen = this.createBagModGen_(zone, zone[index].presetModulatorIndex, zone[index + 1] ? zone[index + 1].instrumentModulatorIndex : this.instrumentZoneModulator.length, this.instrumentZoneModulator);\n    return {\n      modulator: modgen.modgen,\n      modulatorInfo: modgen.modgenInfo\n    };\n  }\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{generator: Object, generatorInfo: Array.<Object>}}\n   * @private\n   */\n  createPresetGenerator_(zone, index) {\n    const modgen = this.createBagModGen_(zone, zone[index].presetGeneratorIndex, zone[index + 1] ? zone[index + 1].presetGeneratorIndex : this.presetZoneGenerator.length, this.presetZoneGenerator);\n    return {\n      generator: modgen.modgen,\n      generatorInfo: modgen.modgenInfo\n    };\n  }\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} index\n   * @return {{modulator: Object, modulatorInfo: Array.<Object>}}\n   * @private\n   */\n  createPresetModulator_(zone, index) {\n    /** @type {{modgen: Object, modgenInfo: Array.<Object>}} */\n    const modgen = this.createBagModGen_(zone, zone[index].presetModulatorIndex, zone[index + 1] ? zone[index + 1].presetModulatorIndex : this.presetZoneModulator.length, this.presetZoneModulator);\n    return {\n      modulator: modgen.modgen,\n      modulatorInfo: modgen.modgenInfo\n    };\n  }\n\n  /**\n   * @param {Array.<Object>} zone\n   * @param {number} indexStart\n   * @param {number} indexEnd\n   * @param {Array} zoneModGen\n   * @return {{modgen: Object, modgenInfo: Array.<Object>}}\n   * @private\n   */\n  createBagModGen_(zone, indexStart, indexEnd, zoneModGen) {\n    /** @type {Array.<Object>} */\n    const modgenInfo = [];\n    /** @type {Object} */\n\n    const modgen = {\n      'unknown': [],\n      'keyRange': {\n        hi: 127,\n        lo: 0\n      }\n    }; // TODO\n\n    /** @type {Object} */\n\n    let info;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n\n    for (i = indexStart, il = indexEnd; i < il; ++i) {\n      info = zoneModGen[i];\n      modgenInfo.push(info);\n\n      if (info.type === 'unknown') {\n        modgen.unknown.push(info.value);\n      } else {\n        modgen[info.type] = info.value;\n      }\n    }\n\n    return {\n      modgen: modgen,\n      modgenInfo: modgenInfo\n    };\n  }\n\n}\n\n/**\n * Synthesizer Class\n * @private\n */\n\nclass Synthesizer {\n  /**\n   * @param {Uint8Array} input\n   */\n  constructor(input) {\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {Uint8Array} */\n\n    this.input = input;\n    /** @type {SoundFont.Parser} */\n\n    this.parser = {};\n    /** @type {number} */\n\n    this.bank = 0;\n    /** @type {Array.<Array.<Object>>} */\n\n    this.bankSet = {};\n    /** @type {number} */\n\n    this.bufferSize = 2048;\n    /** @type {AudioContext} */\n\n    this.ctx = this.getAudioContext();\n    /** @type {GainNode} */\n\n    this.gainMaster = this.ctx.createGain();\n    /** @type {AudioBufferSourceNode} */\n\n    this.bufSrc = this.ctx.createBufferSource();\n    /** @type {Array.<number>} */\n\n    this.channelInstrument = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n\n    this.channelBank = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n\n    this.channelVolume = [127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127];\n    /** @type {Array.<number>} */\n\n    this.channelPanpot = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n\n    this.channelPitchBend = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    /** @type {Array.<number>} */\n\n    this.channelPitchBendSensitivity = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];\n    /** @type {Array.<number>} */\n\n    this.channelExpression = [127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127];\n    /** @type {Array.<number>} */\n\n    this.channelAttack = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n\n    this.channelDecay = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n\n    this.channelSustin = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n\n    this.channelRelease = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<boolean>} */\n\n    this.channelHold = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];\n    /** @type {Array.<number>} */\n\n    this.channelHarmonicContent = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {Array.<number>} */\n\n    this.channelCutOffFrequency = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];\n    /** @type {boolean} */\n\n    this.isGS = false;\n    /** @type {boolean} */\n\n    this.isXG = false;\n    /** @type {Array.<Array.<string>>} */\n\n    this.programSet = [];\n    /** @type {Array.<boolean>} */\n\n    this.channelMute = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];\n    /** @type {Array.<Array.<SoundFont.SynthesizerNote>>} */\n\n    this.currentNoteOn = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];\n    /** @type {number} @const */\n\n    this.baseVolume = 1 / 0xffff;\n    /** @type {number} */\n\n    this.masterVolume = 16384;\n    /** @type {Array.<boolean>} */\n\n    this.percussionPart = [false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false];\n    /** @type {Array.<number>} */\n\n    this.percussionVolume = new Array(128);\n\n    for (i = 0, il = this.percussionVolume.length; i < il; ++i) {\n      this.percussionVolume[i] = 127;\n    }\n\n    this.programSet = {};\n    /** @type {Array.<Reverb>}リバーブエフェクト（チャンネル毎に用意する） */\n\n    this.reverb = [];\n    /** @type {Array.<BiquadFilterNode>} フィルタ（ビブラートなど） */\n\n    this.filter = [];\n\n    for (i = 0; i < 16; ++i) {\n      this.reverb[i] = new Reverb(this.ctx, {\n        mix: 0.315\n      }); // リバーブエフェクトのデフォルト値は40なので40/127の値をドライ／ウェット値となる\n      // フィルタを定義\n\n      this.filter[i] = this.ctx.createBiquadFilter();\n    }\n  }\n  /**\n   * @return {AudioContext}\n   */\n\n\n  getAudioContext() {\n    /** @type {AudioContext} */\n    const ctx = new (window.AudioContext || window.webkitAudioContext)(); // for legacy browsers\n\n    ctx.createGain = ctx.createGain || ctx.createGainNode; // Defreeze AudioContext for iOS.\n\n    const initAudioContext = () => {\n      document.removeEventListener('touchstart', initAudioContext); // wake up AudioContext\n\n      const emptySource = ctx.createBufferSource();\n      emptySource.start();\n      emptySource.stop();\n    };\n\n    document.addEventListener('touchstart', initAudioContext);\n    return ctx;\n  }\n  /**\n   * System Reset\n   * @param {string} mode\n   */\n\n\n  init(mode = 'GM') {\n    this.gainMaster.disconnect();\n    /** @type {number} */\n\n    let i;\n    this.parser = new Parser(this.input, {\n      sampleRate: this.ctx.sampleRate\n    });\n    this.bankSet = this.createAllInstruments();\n    this.isXG = false;\n    this.isGS = false;\n\n    if (mode == 'XG') {\n      this.isXG = true;\n    } else if (mode == 'GS') {\n      this.isGS = true;\n    }\n\n    for (i = 0; i < 16; ++i) {\n      this.programChange(i, 0x00);\n      this.volumeChange(i, 0x64);\n      this.panpotChange(i, 0x40);\n      this.pitchBend(i, 0x00, 0x40); // 8192\n\n      this.pitchBendSensitivity(i, 2);\n      this.channelHold[i] = false;\n      this.channelExpression[i] = 127;\n      this.channelBank[i] = i === 9 ? 127 : 0;\n      this.attackTime(i, 64);\n      this.decayTime(i, 64);\n      this.sustinTime(i, 64);\n      this.releaseTime(i, 64);\n      this.harmonicContent(i, 64);\n      this.cutOffFrequency(i, 64);\n      this.reverbDepth(i, 40);\n      this.updateBankSelect(i);\n      this.updateProgramSelect(i);\n    }\n\n    this.setPercussionPart(9, true);\n\n    for (i = 0; i < 128; ++i) {\n      this.percussionVolume[i] = 127;\n    }\n\n    this.gainMaster.connect(this.ctx.destination);\n    /*\n    if (this.element) {\n      this.element.querySelector('.header div:before').innerText = mode + ' Mode';\n      this.element.dataset.mode = mode;\n    }\n    */\n  }\n  /**\n   */\n\n\n  close() {\n    this.ctx.close();\n  }\n  /**\n   * @param {Uint8Array} input\n   */\n\n\n  refreshInstruments(input) {\n    this.input = input;\n    this.parser = new Parser(input);\n    this.bankSet = this.createAllInstruments();\n  }\n  /** @return {Array.<Array.<Object>>} */\n\n\n  createAllInstruments() {\n    /** @type {SoundFont.Parser} */\n    const parser = this.parser;\n    parser.parse();\n    /** @type {Array} TODO */\n\n    const presets = parser.createPreset();\n    /** @type {Array} TODO */\n\n    const instruments = parser.createInstrument();\n    /** @type {Array} */\n\n    const banks = [];\n    /** @type {Array.<Array.<Object>>} */\n\n    let bank;\n    /** @type {number} */\n\n    let bankNumber;\n    /** @type {Object} TODO */\n\n    let preset;\n    /** @type {Object} */\n\n    let instrument;\n    /** @type {number} */\n\n    let presetNumber;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {number} */\n\n    let j;\n    /** @type {number} */\n\n    let jl;\n    /** @type {string} */\n\n    let presetName;\n    const programSet = [];\n\n    for (i = 0, il = presets.length; i < il; ++i) {\n      preset = presets[i];\n      presetNumber = preset.header.preset;\n      bankNumber = preset.header.bank;\n      presetName = preset.name.replace(/\\0*$/, '');\n\n      if (typeof preset.instrument !== 'number') {\n        continue;\n      }\n\n      instrument = instruments[preset.instrument];\n\n      if (instrument.name.replace(/\\0*$/, '') === 'EOI') {\n        continue;\n      } // select bank\n\n\n      if (banks[bankNumber] === void 0) {\n        banks[bankNumber] = [];\n      }\n\n      bank = banks[bankNumber];\n      bank[presetNumber] = {};\n      bank[presetNumber].name = presetName;\n\n      for (j = 0, jl = instrument.info.length; j < jl; ++j) {\n        this.createNoteInfo(parser, instrument.info[j], bank[presetNumber]);\n      }\n\n      if (!programSet[bankNumber]) {\n        programSet[bankNumber] = {};\n      }\n\n      programSet[bankNumber][presetNumber] = presetName;\n    }\n\n    this.programSet = programSet;\n    return banks;\n  }\n  /**\n   * @param {Parser} parser\n   * @param {*} info\n   * @param {*} preset\n   */\n\n\n  createNoteInfo(parser, info, preset) {\n    /** @type {Generator} */\n    const generator = info.generator;\n\n    if (generator.keyRange === void 0 || generator.sampleID === void 0) {\n      return;\n    } // console.log(generator);\n\n    /** @type {number} */\n\n\n    const volDelay = this.getModGenAmount(generator, 'delayVolEnv', -12000);\n    /** @type {number} */\n\n    const volAttack = this.getModGenAmount(generator, 'attackVolEnv', -12000);\n    /** @type {number} */\n\n    const volHold = this.getModGenAmount(generator, 'holdVolEnv', -12000);\n    /** @type {number} */\n\n    const volDecay = this.getModGenAmount(generator, 'decayVolEnv', -12000);\n    /** @type {number} */\n\n    const volSustain = this.getModGenAmount(generator, 'sustainVolEnv');\n    /** @type {number} */\n\n    const volRelease = this.getModGenAmount(generator, 'releaseVolEnv', -12000);\n    /** @type {number} */\n\n    const modDelay = this.getModGenAmount(generator, 'delayModEnv', -12000);\n    /** @type {number} */\n\n    const modAttack = this.getModGenAmount(generator, 'attackModEnv', -12000);\n    /** @type {number} */\n\n    const modHold = this.getModGenAmount(generator, 'holdModEnv', -12000);\n    /** @type {number} */\n\n    const modDecay = this.getModGenAmount(generator, 'decayModEnv', -12000);\n    /** @type {number} */\n\n    const modSustain = this.getModGenAmount(generator, 'sustainModEnv');\n    /** @type {number} */\n\n    const modRelease = this.getModGenAmount(generator, 'releaseModEnv', -12000);\n    /** @type {number} */\n\n    const scale = this.getModGenAmount(generator, 'scaleTuning', 100) / 100;\n    /** @type {number} */\n\n    const freqVibLFO = this.getModGenAmount(generator, 'freqVibLFO');\n    /** @type {number} */\n\n    const pan = this.getModGenAmount(generator, 'pan');\n    /** @type {number} */\n\n    const tune = this.getModGenAmount(generator, 'coarseTune') + this.getModGenAmount(generator, 'fineTune') / 100;\n\n    for (let i = generator.keyRange.lo, il = generator.keyRange.hi; i <= il; ++i) {\n      if (preset[i]) {\n        continue;\n      }\n      /** @type {number} */\n\n\n      const sampleId = this.getModGenAmount(generator, 'sampleID');\n      /** @type {object} */\n\n      const sampleHeader = parser.sampleHeader[sampleId];\n      preset[i] = {\n        'sample': parser.sample[sampleId],\n        'sampleRate': sampleHeader.sampleRate,\n        'sampleModes': this.getModGenAmount(generator, 'sampleModes'),\n        'basePlaybackRate': 1.0594630943592953 // Math.pow(2, 1 / 12)\n        ** ((i - this.getModGenAmount(generator, 'overridingRootKey', sampleHeader.originalPitch) + tune + sampleHeader.pitchCorrection / 100) * scale),\n        'modEnvToPitch': this.getModGenAmount(generator, 'modEnvToPitch') / 100,\n        'scaleTuning': scale,\n        'start': this.getModGenAmount(generator, 'startAddrsCoarseOffset') * 32768 + this.getModGenAmount(generator, 'startAddrsOffset'),\n        'end': this.getModGenAmount(generator, 'endAddrsCoarseOffset') * 32768 + this.getModGenAmount(generator, 'endAddrsOffset'),\n        'loopStart': // (sampleHeader.startLoop - sampleHeader.start) +\n        sampleHeader.startLoop + this.getModGenAmount(generator, 'startloopAddrsCoarseOffset') * 32768 + this.getModGenAmount(generator, 'startloopAddrsOffset'),\n        'loopEnd': // (sampleHeader.endLoop - sampleHeader.start) +\n        sampleHeader.endLoop + this.getModGenAmount(generator, 'endloopAddrsCoarseOffset') * 32768 + this.getModGenAmount(generator, 'endloopAddrsOffset'),\n        'volDelay': 2 ** (volDelay / 1200),\n        'volAttack': 2 ** (volAttack / 1200),\n        'volHold': 2 ** (volHold / 1200) * 2 ** ((60 - i) * this.getModGenAmount(generator, 'keynumToVolEnvHold') / 1200),\n        'volDecay': 2 ** (volDecay / 1200) * 2 ** ((60 - i) * this.getModGenAmount(generator, 'keynumToVolEnvDecay') / 1200),\n        'volSustain': volSustain / 1000,\n        'volRelease': 2 ** (volRelease / 1200),\n        'modDelay': 2 ** (modDelay / 1200),\n        'modAttack': 2 ** (modAttack / 1200),\n        'modHold': 2 ** (modHold / 1200) * 2 ** ((60 - i) * this.getModGenAmount(generator, 'keynumToModEnvHold') / 1200),\n        'modDecay': 2 ** (modDecay / 1200) * 2 ** ((60 - i) * this.getModGenAmount(generator, 'keynumToModEnvDecay') / 1200),\n        'modSustain': modSustain / 1000,\n        'modRelease': 2 ** (modRelease / 1200),\n        'initialFilterFc': this.getModGenAmount(generator, 'initialFilterFc', 13500),\n        'modEnvToFilterFc': this.getModGenAmount(generator, 'modEnvToFilterFc'),\n        'initialFilterQ': this.getModGenAmount(generator, 'initialFilterQ'),\n        'reverbEffectSend': this.getModGenAmount(generator, 'reverbEffectSend'),\n        'initialAttenuation': this.getModGenAmount(generator, 'initialAttenuation'),\n        'freqVibLFO': freqVibLFO ? 2 ** (freqVibLFO / 1200) * 8.176 : void 0,\n        'pan': pan ? pan / 1200 : void 0\n      };\n    }\n  }\n\n  /**\n   * @param {Object} generator\n   * @param {string} enumeratorType\n   * @param {number=} optDefault\n   * @return {number}\n   */\n  getModGenAmount(generator, enumeratorType, optDefault = null) {\n    return generator[enumeratorType] ? generator[enumeratorType].amount : optDefault;\n  }\n  /**\n   */\n\n\n  start() {\n    this.connect();\n    this.bufSrc.start(0);\n    this.setMasterVolume(16383);\n  }\n  /**\n   * @param {number} volume\n   */\n\n\n  setMasterVolume(volume) {\n    this.masterVolume = volume;\n    this.gainMaster.gain.value = this.baseVolume * (volume / 16384);\n  }\n  /**\n   */\n\n\n  connect() {\n    this.bufSrc.connect(this.gainMaster);\n  }\n  /**\n   */\n\n\n  disconnect() {\n    this.bufSrc.disconnect(this.gainMaster);\n    this.bufSrc.buffer = null;\n  }\n  /**\n   * @param {number} channel NoteOn するチャンネル.\n   * @param {number} key NoteOn するキー.\n   * @param {number} velocity 強さ.\n   */\n\n\n  noteOn(channel, key, velocity) {\n    /** @type {number} */\n    const bankIndex = this.channelBank[channel];\n    /** @type {Object} */\n\n    const bank = typeof this.bankSet[bankIndex] === 'object' ? this.bankSet[bankIndex] : this.bankSet[0];\n    /** @type {Object} */\n\n    let instrument;\n\n    if (typeof bank[this.channelInstrument[channel]] === 'object') {\n      // 音色が存在する場合\n      instrument = bank[this.channelInstrument[channel]];\n    } else if (this.percussionPart[channel] == true) {\n      // パーカッションバンクが選択されている場合で音色が存在しない場合Standard Kitを選択\n      instrument = this.bankSet[this.isXG ? 127 : 128][0];\n    } else {\n      // 通常バンクが選択されている状態で音色が存在しない場合バンク0を選択\n      instrument = this.bankSet[0][this.channelInstrument[channel]];\n    }\n\n    if (instrument[key] === void 0) {\n      // TODO\n      console.warn('instrument not found: bank=%s instrument=%s channel=%s key=%s', bankIndex, this.channelInstrument[channel], channel, key);\n      return;\n    }\n    /** @type {Object} */\n\n\n    const instrumentKey = instrument[key];\n    /** @type {number} */\n\n    let panpot = this.channelPanpot[channel] === 0 ? Math.random() * 127 | 0 : this.channelPanpot[channel] - 64;\n    panpot /= panpot < 0 ? 64 : 63; // create note information\n\n    instrumentKey['channel'] = channel;\n    instrumentKey['key'] = key;\n    instrumentKey['velocity'] = velocity;\n    instrumentKey['panpot'] = panpot;\n    instrumentKey['volume'] = this.channelVolume[channel] / 127;\n    instrumentKey['pitchBend'] = this.channelPitchBend[channel] - 8192;\n    instrumentKey['expression'] = this.channelExpression[channel];\n    instrumentKey['pitchBendSensitivity'] = Math.round(this.channelPitchBendSensitivity[channel]);\n    instrumentKey['mute'] = this.channelMute[channel];\n    instrumentKey['releaseTime'] = this.channelRelease[channel];\n    instrumentKey['cutOffFrequency'] = this.cutOffFrequency[channel];\n    instrumentKey['harmonicContent'] = this.harmonicContent[channel];\n    instrumentKey['reverb'] = this.reverb[channel]; // percussion\n\n    if (bankIndex > 125) {\n      if (key === 42 || key === 44) {\n        // 42: Closed Hi-Hat\n        // 44: Pedal Hi-Hat\n        // 46: Open Hi-Hat\n        this.noteOff(channel, 46, 0);\n      }\n\n      if (key === 80) {\n        // 80: Mute Triangle\n        // 81: Open Triangle\n        this.noteOff(channel, 81, 0);\n      }\n\n      instrument['volume'] *= this.percussionVolume[key] / 127;\n    } // note on\n\n    /** @type {SynthesizerNote} */\n\n\n    const note = new SynthesizerNote(this.ctx, this.gainMaster, instrumentKey);\n    note.noteOn();\n    this.currentNoteOn[channel].push(note);\n    this.updateSynthElement(channel, key, velocity);\n  }\n  /**\n   * @param {number} channel NoteOff するチャンネル.\n   * @param {number} key NoteOff するキー.\n   * @param {number} velocity 強さ.\n   */\n\n\n  noteOff(channel, key, velocity) {\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {Array.<SynthesizerNote>} */\n\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {SynthesizerNote} */\n\n    let note;\n    /** @type {boolean} */\n\n    const hold = this.channelHold[channel];\n\n    for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n      note = currentNoteOn[i];\n\n      if (note.key === key) {\n        note.noteOff(); // hold している時は NoteOff にはするがリリースはしない\n\n        if (!hold) {\n          note.release();\n          currentNoteOn.splice(i, 1);\n          --i;\n          --il;\n        }\n      }\n    }\n\n    this.updateSynthElement(channel, key, 0);\n  }\n  /**\n   * @param {number} channel ホールドするチャンネル\n   * @param {number} value 値\n   */\n\n\n  hold(channel, value) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {boolean} */\n\n    const hold = this.channelHold[channel] = !(value < 64);\n    /** @type {SynthesizerNote} */\n\n    let note;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n\n    if (!hold) {\n      for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n        note = currentNoteOn[i];\n\n        if (note.isNoteOff()) {\n          note.release();\n          currentNoteOn.splice(i, 1);\n          --i;\n          --il;\n        }\n      }\n    }\n\n    if (this.element) {\n      /** @type {HTMLDivElement} */\n      const channelElement = this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ')');\n\n      if (this.channelHold[channel]) {\n        channelElement.classList.add('hold');\n      } else {\n        channelElement.classList.remove('hold');\n      }\n    }\n  }\n  /**\n   * @param {number} channel チャンネルのバンクセレクトMSB\n   * @param {number} value 値\n   */\n\n\n  bankSelectMsb(channel, value) {\n    if (this.isXG) {\n      // 念の為バンクを0にリセット\n      this.channelBank[channel] = 0; // XG音源は、MSB→LSBの優先順でバンクセレクトをする。\n\n      if (value === 64) {\n        // Bank Select MSB #64 (Voice Type: SFX)\n        this.channelBank[channel] = 125;\n        this.percussionPart[channel] = true;\n      } else if (value === 126 || value === 127) {\n        // Bank Select MSB #126 (Voice Type: Drum)\n        // Bank Select MSB #127 (Voice Type: Drum)\n        this.channelBank[channel] = value;\n        this.percussionPart[channel] = true;\n      }\n    } else if (this.isGS) {\n      // GS音源\n      // ※チャンネル10のバンク・セレクト命令は無視する。\n      this.channelBank[channel] = channel === 9 ? 128 : value;\n      this.percussionPart[channel] = value === 128;\n    } else {\n      // GM音源モードのときはバンク・セレクトを無視\n      return;\n    }\n\n    this.updateBankSelect(channel);\n  }\n  /**\n   * @param {number} channel チャンネルのバンクセレクトLSB\n   * @param {number} value 値\n   */\n\n\n  bankSelectLsb(channel, value) {\n    // XG音源以外は処理しない\n    if (!this.isXG || this.percussionPart[channel] === true) {\n      return;\n    } // 125より値が大きい場合、パーカッションとして処理\n\n\n    this.percussionPart[channel] = value >= 125;\n    this.channelBank[channel] = value;\n    this.updateBankSelect(channel);\n  }\n  /**\n   * @param {number} channel 音色を変更するチャンネル.\n   * @param {number} instrument 音色番号.\n   */\n\n\n  programChange(channel, instrument) {\n    this.channelInstrument[channel] = instrument;\n    this.bankChange(channel, this.channelBank[channel]);\n\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') .program > select').value = instrument;\n    }\n  }\n  /**\n   * @param {number} channel 音色を変更するチャンネル.\n   * @param {number} bank バンク・セレクト.\n   */\n\n\n  bankChange(channel, bank) {\n    if (typeof this.bankSet[bank] === 'object') {\n      // バンクが存在するとき\n      this.channelBank[channel] = bank;\n    } else {\n      // バンクが存在しないとき\n      if (this.percussionPart[channel]) {\n        // パーカッション\n        this.channelBank[channel] = !this.isXG ? 128 : 127;\n      } else {\n        // 存在しない場合0を選択\n        this.channelBank[channel] = 0;\n      }\n    } // TODO: 厳密にはMIDI音源はプログラムチェンジがあったときにバンク・セレクトが反映される。\n\n\n    this.updateProgramSelect(channel);\n\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .bank > select').value = bank;\n    }\n  }\n  /**\n   * @param {number} channel 音量を変更するチャンネル.\n   * @param {number} volume 音量(0-127).\n   */\n\n\n  volumeChange(channel, volume) {\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .volume var').innerText = volume;\n    }\n\n    this.channelVolume[channel] = volume;\n  }\n  /**\n   * @param {number} channel 音量を変更するチャンネル.\n   * @param {number} expression 音量(0-127).\n   */\n\n\n  expression(channel, expression) {\n    /** @type {number} */\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {Array.<SynthesizerNote>} */\n\n    const currentNoteOn = this.currentNoteOn[channel];\n\n    for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n      currentNoteOn[i].updateExpression(expression);\n    }\n\n    this.channelExpression[channel] = expression;\n  }\n  /**\n   * @param {number} channel panpot を変更するチャンネル.\n   * @param {number} panpot panpot(0-127).\n   */\n\n\n  panpotChange(channel, panpot) {\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .panpot > meter').value = panpot;\n    }\n\n    this.channelPanpot[channel] = panpot;\n  }\n  /**\n   * @param {number} channel panpot を変更するチャンネル.\n   * @param {number} lowerByte\n   * @param {number} higherByte\n   */\n\n\n  pitchBend(channel, lowerByte, higherByte) {\n    /** @type {number} */\n    const bend = lowerByte & 0x7f | (higherByte & 0x7f) << 7;\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n    /** @type {Array.<SoundFont.SynthesizerNote>} */\n\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {number} */\n\n    const calculated = bend - 8192;\n\n    if (this.element) {\n      this.element.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .pitchBend > meter').value = calculated;\n    }\n\n    for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n      currentNoteOn[i].updatePitchBend(calculated);\n    }\n\n    this.channelPitchBend[channel] = bend;\n  }\n  /**\n   * @param {number} channel pitch bend sensitivity を変更するチャンネル.\n   * @param {number} sensitivity\n   */\n\n\n  pitchBendSensitivity(channel, sensitivity) {\n    if (this.element) {\n      document.querySelector('.instrument > .channel:nth-child(' + (channel + 1) + ') > .pitchBendSensitivity > var').innerText = sensitivity;\n    }\n\n    this.channelPitchBendSensitivity[channel] = sensitivity;\n  }\n  /**\n   * @param {number} channel\n   * @param {number} attackTime\n   */\n\n\n  attackTime(channel, attackTime) {\n    this.channelAttack[channel] = attackTime;\n  }\n  /**\n   * @param {number} channel\n   * @param {number} decayTime\n   */\n\n\n  decayTime(channel, decayTime) {\n    this.channelDecay[channel] = decayTime;\n  }\n  /**\n   * @param {number} channel\n   * @param {number} sustinTime\n   */\n\n\n  sustinTime(channel, sustinTime) {\n    this.channelSustin[channel] = sustinTime;\n  }\n  /**\n   * @param {number} channel\n   * @param {number} releaseTime\n   */\n\n\n  releaseTime(channel, releaseTime) {\n    this.channelRelease[channel] = releaseTime;\n  }\n  /**\n   * @param {number} channel\n   * @param {number} value\n   */\n\n\n  harmonicContent(channel, value) {\n    this.channelHarmonicContent[channel] = value;\n  }\n  /**\n   * @param {number} channel\n   * @param {number} value\n   */\n\n\n  cutOffFrequency(channel, value) {\n    this.channelCutOffFrequency[channel] = value;\n  }\n  /**\n   * リバーブエフェクト\n   * @param {number} channel\n   * @param {number} depth\n   */\n\n\n  reverbDepth(channel, depth) {\n    // リバーブ深度は、ドライ／ウェット比とする。\n    this.reverb[channel].mix(depth / 127);\n  }\n  /**\n   * モデュレーター\n   * @param {number} channel\n   * @param {number} depth\n   */\n\n\n  modulationDepth(channel, depth) {} // TODO: LFOの反映量\n  // this.filter[channel].mix(depth / 127);\n\n  /**\n   * @param {number} channel pitch bend sensitivity を取得するチャンネル.\n   * @return {number}\n   */\n\n\n  getPitchBendSensitivity(channel) {\n    return this.channelPitchBendSensitivity[channel];\n  }\n  /**\n   * @param {number} key\n   * @param {number} volume\n   */\n\n\n  drumInstrumentLevel(key, volume) {\n    this.percussionVolume[key] = volume;\n  }\n  /**\n   * @param {number} channel NoteOff するチャンネル.\n   */\n\n\n  allNoteOff(channel) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel]; // ホールドを解除\n\n    this.hold(channel, 0); // 再生中の音をすべて止める\n\n    while (currentNoteOn.length > 0) {\n      this.noteOff(channel, currentNoteOn[0].key, 0);\n    }\n  }\n  /**\n   * @param {number} channel 音を消すチャンネル.\n   */\n\n\n  allSoundOff(channel) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {SynthesizerNote} */\n\n    let note;\n\n    while (currentNoteOn.length > 0) {\n      note = currentNoteOn.shift();\n      this.noteOff(channel, note.key, 0);\n      note.release();\n      note.disconnect();\n    } // ホールドを解除\n\n\n    this.hold(channel, 0);\n  }\n  /**\n   * @param {number} channel リセットするチャンネル\n   */\n\n\n  resetAllControl(channel) {\n    this.allNoteOff(channel);\n    this.expression(channel, 127);\n    this.pitchBend(channel, 0x00, 0x40);\n  }\n  /**\n   * @param {number} channel ミュートの設定を変更するチャンネル.\n   * @param {boolean} mute ミュートにするなら true.\n   */\n\n\n  mute(channel, mute) {\n    /** @type {Array.<SynthesizerNote>} */\n    const currentNoteOn = this.currentNoteOn[channel];\n    /** @type {number} */\n\n    let i;\n    /** @type {number} */\n\n    let il;\n    this.channelMute[channel] = mute;\n\n    if (mute) {\n      for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n        currentNoteOn[i].disconnect();\n      }\n    } else {\n      for (i = 0, il = currentNoteOn.length; i < il; ++i) {\n        currentNoteOn[i].connect();\n      }\n    }\n  }\n  /**\n   * @param {number} channel TODO:ドラムパートとしてセットするチャンネル\n   * @param {boolean} sw ドラムか通常かのスイッチ\n   */\n\n\n  setPercussionPart(channel, sw) {\n    if (!this.isXG) {\n      this.channelBank[channel] = 128;\n    } else {\n      this.channelBank[channel] = 127;\n    }\n\n    this.percussionPart[channel] = sw;\n  }\n\n}\n\n/**\n * @param {File} file\n */\n\nfunction readFileAsArrayBuffer(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = () => resolve(reader.result);\n\n    reader.onerror = error => reject(error);\n\n    reader.readAsArrayBuffer(file);\n  });\n}\n/**\n * @param {string} URL\n */\n\n\nasync function fetchResourceAsArrayBuffer(url) {\n  const response = await fetch(url);\n\n  if (!response.ok) {\n    throw new Error('Did not get an OK response when fetching resource.');\n  }\n\n  const arrayBuffer = await response.arrayBuffer();\n  return arrayBuffer;\n}\n\nconst waitForReference = ref => new Promise(resolve => {\n  const iid = setInterval(() => {\n    if (ref !== undefined) {\n      clearInterval(iid);\n      resolve();\n    }\n  }, 16);\n});\n\nclass SoundFont {\n  constructor() {\n    this.synth = undefined;\n    this._channel = 0;\n    this._bankIndex = 0;\n    this._programIndex = 0;\n  }\n\n  set channel(channel) {\n    this._channel = channel;\n  }\n  /**\n   *\n   * @param {File} file\n   */\n\n\n  async loadSoundFontFromFile(file) {\n    const arrayBuffer = await readFileAsArrayBuffer(file);\n    this.bootSynth(arrayBuffer);\n  }\n  /**\n   *\n   * @param {string} url\n   */\n\n\n  async loadSoundFontFromURL(url) {\n    const arrayBuffer = await fetchResourceAsArrayBuffer(url);\n    this.bootSynth(arrayBuffer);\n  }\n\n  set bank(index) {\n    this._bankIndex = index;\n    this.synth.bankChange(this._channel, index);\n  }\n\n  get banks() {\n    return Object.keys(this.synth.programSet).map(id => ({\n      id,\n      name: ('000' + parseInt(id, 10)).slice(-3)\n    }));\n  }\n\n  set program(index) {\n    this._programIndex = index;\n    this.synth.programChange(this._channel, index);\n  }\n\n  get programs() {\n    const {\n      programSet\n    } = this.synth;\n    return Object.keys(programSet[this._bankIndex]).map(id => ({\n      id,\n      name: ('000' + (parseInt(id) + 1)).slice(-3) + ':' + programSet[this._bankIndex][id]\n    }));\n  }\n  /**\n   * @param {ArrayBuffer} arrayBuffer\n   */\n\n\n  async bootSynth(arrayBuffer) {\n    const input = new Uint8Array(arrayBuffer);\n\n    if (this.synth) {\n      this.synth.refreshInstruments(input);\n    } else {\n      this.synth = new Synthesizer(input);\n      this.synth.init();\n      this.synth.start();\n      await waitForReference(this.synth.programSet);\n      console.log(this.synth);\n      console.log(this.banks);\n      console.log(this.programs);\n    }\n  }\n  /**\n   *\n   * @param {number} midiNumber\n   */\n\n\n  noteOn(midiNumber) {\n    const volume = 127;\n    this.synth.noteOn(this._channel, midiNumber, volume);\n  }\n  /**\n   *\n   * @param {number} midiNumber\n   */\n\n\n  noteOff(midiNumber) {\n    const volume = 127;\n    this.synth.noteOff(this._channel, midiNumber, volume);\n  }\n\n}\n\nexport default SoundFont;\n//# sourceMappingURL=index.js.map\n"],"names":["SynthesizerNote","[object Object]","ctx","destination","instrument","channel","key","velocity","buffer","playbackRate","loopStart","loopEnd","sampleRate","volume","panpot","pitchBend","pitchBendSensitivity","modEnvToPitch","expression","cutOffFrequency","hermonicContent","reverb","startTime","currentTime","computedPlaybackRate","this","noteOffState","audioBuffer","bufferSource","createBufferSource","panner","createPanner","outputGainNode","createGain","expressionGainNode","filter","createBiquadFilter","modulator","now","volDelay","modDelay","volAttack","modAttack","volHold","modHold","volDecay","modDecay","pan","sample","subarray","length","createBuffer","getChannelData","set","loop","updatePitchBend","output","gain","value","panningModel","setPosition","Math","sin","PI","cos","outputGain","setValueAtTime","setTargetAtTime","linearRampToValueAtTime","baseFreq","amountToFreq","peekFreq","sustainFreq","Q","frequency","type","parseFloat","connect","start","val","release","volEndTime","modEndTime","disconnect","cancelScheduledValues","stop","console","error","computed","peekPitch","schedulePlaybackRate"],"mappings":"yVAIO,MAAMA,EAeXC,YAAYC,EAAKC,EAAaC,QAEvBF,IAAMA,OAGNC,YAAcA,OAadC,WAAaA,OAGbC,QAAUD,EAAU,aAGpBE,IAAMF,EAAU,SAGhBG,SAAWH,EAAU,cAGrBI,OAASJ,EAAU,YAGnBK,aAAeL,EAAU,sBAGzBM,UAAYN,EAAU,eAGtBO,QAAUP,EAAU,aAGpBQ,WAAaR,EAAU,gBAGvBS,OAAST,EAAU,YAGnBU,OAASV,EAAU,YAGnBW,UAAYX,EAAU,eAGtBY,qBAAuBZ,EAAU,0BAGjCa,cAAgBb,EAAU,mBAG1Bc,WAAad,EAAU,gBAGvBe,gBAAkBf,EAAU,qBAG5BgB,gBAAkBhB,EAAU,qBAG5BiB,OAASjB,EAAU,YAInBkB,UAAYpB,EAAIqB,iBAGhBC,qBAA2C,EAApBC,KAAKhB,kBAG5BiB,cAAe,OAMfC,iBAGAC,aAAe1B,EAAI2B,0BAGnBC,OAAS5B,EAAI6B,oBAGbC,eAAiB9B,EAAI+B,kBAGrBC,mBAAqBhC,EAAI+B,kBAGzBE,OAASjC,EAAIkC,0BAGbC,UAAYnC,EAAIkC,qBAMvBnC,aAEQC,EAAMuB,KAAKvB,IAYXE,EAAaqB,KAAKrB,WAIlBkC,EAAMb,KAAKvB,IAAIqB,aAAe,EAG9BgB,EAAWD,EAAMlC,EAAU,SAG3BoC,EAAWF,EAAMlC,EAAU,SAG3BqC,EAAYF,EAAWnC,EAAU,UAGjCsC,EAAYH,EAAWnC,EAAU,UAGjCuC,EAAUF,EAAYrC,EAAU,QAGhCwC,EAAUF,EAAYtC,EAAU,QAGhCyC,EAAWF,EAAUvC,EAAU,SAG/B0C,EAAWF,EAAUxC,EAAU,SAG/BM,EAAYN,EAAU,UAAgBqB,KAAKb,WAG3CD,EAAUP,EAAU,QAAcqB,KAAKb,WAGvCU,EAAYlB,EAAU,MAAYqB,KAAKb,WAKvCmC,OAA4B,IAAtB3C,EAAU,IAAqBA,EAAU,IAAUqB,KAAKX,OAC9DkC,EAASvB,KAAKjB,OAAOyC,SAAS,EAAGxB,KAAKjB,OAAO0C,OAAS9C,EAAU,KAGhEI,EAASiB,KAAKE,YAAczB,EAAIiD,aAAa,EAAGH,EAAOE,OAAQzB,KAAKb,YAGtDJ,EAAO4C,eAAe,GAC9BC,IAAIL,OAIVpB,EAAeH,KAAKG,aAC1BA,EAAapB,OAASA,EACtBoB,EAAa0B,KAAmC,EAA5BlD,EAAU,aAAuB,EACrDwB,EAAalB,UAAYA,EACzBkB,EAAajB,QAAUA,OAClB4C,gBAAgB9B,KAAKV,eAIpByC,EAAS/B,KAAKO,oBAEfE,mBAAmBuB,KAAKC,MAAQjC,KAAKP,WAAa,QAIjDY,EAASL,KAAKK,OACpBA,EAAO6B,aAAe,aAEtB7B,EAAO8B,YAAYC,KAAKC,IAAIf,EAAMc,KAAKE,GAAK,GAAI,EAAGF,KAAKG,IAAIjB,EAAMc,KAAKE,GAAK,QAMxElD,EAASY,KAAKZ,QAAUY,KAAKlB,SAAW,MAAQ,EAAIH,EAAU,mBAAyB,KAEvFS,EAAS,IACXA,EAAS,OAMLoD,EAAaT,EAAOC,KAC1BQ,EAAWC,eAAe,EAAG5B,GAC7B2B,EAAWC,eAAe,EAAG3B,GAC7B0B,EAAWE,gBAAgBtD,EAAQ0B,EAAUnC,EAAU,WACvD6D,EAAWC,eAAerD,EAAQ8B,GAClCsB,EAAWG,wBAAwBvD,GAAU,EAAIT,EAAU,YAAiByC,OAItEwB,EAAW5C,KAAK6C,aAAalE,EAAU,iBAGvCmE,EAAW9C,KAAK6C,aAAalE,EAAU,gBAAsBA,EAAU,kBAGvEoE,EAAcH,GAAYE,EAAWF,IAAa,EAAIjE,EAAU,YAGhEiC,EAAYZ,KAAKY,UACvBA,EAAUoC,EAAEP,eAAe,KAAO9D,EAAU,eAAqB,KAAMkC,GACvED,EAAUqC,UAAUhB,MAAQW,EAC5BhC,EAAUsC,KAAO,UACjBtC,EAAUqC,UAAUP,gBAAgBE,EAAW,IAAK5C,KAAKvB,IAAIqB,YAAa,IAC1Ec,EAAUqC,UAAUR,eAAeG,EAAU/B,GAC7CD,EAAUqC,UAAUR,eAAeG,EAAU7B,GAC7CH,EAAUqC,UAAUP,gBAAgBI,EAAU/B,EAAUoC,WAAWxE,EAAU,UAAgB,IAE7FiC,EAAUqC,UAAUR,eAAeK,EAAU3B,GAC7CP,EAAUqC,UAAUN,wBAAwBI,EAAa1B,GAEzDlB,EAAaiD,QAAQxC,GACrBA,EAAUwC,QAAQ/C,GAClBA,EAAO+C,QAAQpD,KAAKS,yBACfA,mBAAmB2C,QAAQrB,GAE3BpD,EAAU,WACRyE,UAIPjD,EAAakD,MAAM,EAAGxD,GAQxBrB,aAAa8E,UACJ,KAAOA,EAAM,MAAQ,MAAQ,IAMtC9E,eACOyB,cAAe,EAOtBzB,mBACSwB,KAAKC,aAOdzB,cAWQG,EAAaqB,KAAKrB,WAGlBwB,EAAeH,KAAKG,aAGpB4B,EAAS/B,KAAKO,eAGdM,EAAMb,KAAKvB,IAAIqB,YACfyD,EAAU5E,EAAU,YAAkB,GAStC6E,EAAa3C,EAHGlC,EAAU,WAAiBoD,EAAOC,KAAKC,OAGnB,EAAIsB,GAAWA,EAAU,EAAI,GAAK,KAOtE3C,EAAYZ,KAAKY,UAGjBgC,EAAW5C,KAAK6C,aAAalE,EAAU,iBAGvCmE,EAAW9C,KAAK6C,aAAalE,EAAU,gBAAsBA,EAAU,kBAGvE8E,EAAa5C,EAAMlC,EAAU,YAAkBiE,IAAaE,EAAW,GAAKlC,EAAUqC,UAAUhB,MAAQW,IAAaE,EAAWF,OAEjI5C,KAAKE,mBAOFvB,EAAU,kBACX,EAEHwB,EAAa0B,MAAO,EACpB1B,EAAauD,aACbvD,EAAapB,OAAS,gBAGnB,EAEHgD,EAAOC,KAAK2B,sBAAsB,GAClC5B,EAAOC,KAAKS,eAAeV,EAAOC,KAAKC,MAAOpB,GAC9CkB,EAAOC,KAAKW,wBAAwB,EAAGa,GACvC5C,EAAUqC,UAAUU,sBAAsB,GAC1C/C,EAAUqC,UAAUR,eAAe7B,EAAUqC,UAAUhB,MAAOpB,GAC9DD,EAAUqC,UAAUN,wBAAwBC,EAAUa,GACtDtD,EAAanB,aAAa2E,sBAAsB,GAChDxD,EAAanB,aAAayD,eAAetC,EAAanB,aAAaiD,MAAOpB,GAC1EV,EAAanB,aAAa2D,wBAAwB3C,KAAKD,qBAAsB0D,GAC7EtD,EAAayD,KAAKJ,cAGf,EAEHK,QAAQC,MAAM,wCAGX,EAEH/B,EAAOC,KAAK2B,sBAAsB,GAClC5B,EAAOC,KAAKS,eAAeV,EAAOC,KAAKC,MAAOpB,GAC9CkB,EAAOC,KAAKW,wBAAwB,EAAGa,GACvC5C,EAAUqC,UAAUU,sBAAsB,GAC1C/C,EAAUqC,UAAUR,eAAe7B,EAAUqC,UAAUhB,MAAOpB,GAC9DD,EAAUqC,UAAUN,wBAAwBC,EAAUa,GACtDtD,EAAanB,aAAa2E,sBAAsB,GAChDxD,EAAanB,aAAayD,eAAetC,EAAanB,aAAaiD,MAAOpB,GAC1EV,EAAanB,aAAa2D,wBAAwB3C,KAAKD,qBAAsB0D,WAG7EtD,EAAa0B,MAAO,GAQ1BrD,eACOoB,OAAOwD,QAAQpD,KAAKO,gBAAgB6C,QAAQpD,KAAKtB,aAMxDF,kBACO+B,eAAemD,WAAW,GAMjClF,2BACQQ,EAAegB,KAAKG,aAAanB,aAGjC+E,EAAW/D,KAAKD,qBAGhBsD,EAAQrD,KAAKH,UAGblB,EAAaqB,KAAKrB,WAGlBsC,EAAYoC,EAAQ1E,EAAU,UAG9B0C,EAAWJ,EAAYtC,EAAU,SAGjCqF,EAAYD,EAAW,qBACzB/D,KAAKR,cAAgBQ,KAAKrB,WAAL,aACzBK,EAAa2E,sBAAsB,GACnC3E,EAAayD,eAAesB,EAAUV,GACtCrE,EAAa2D,wBAAwBqB,EAAW/C,GAChDjC,EAAa2D,wBAAwBoB,GAAYC,EAAYD,IAAa,EAAIpF,EAAU,YAAiB0C,GAO3G7C,iBAAiBiB,QACVgB,mBAAmBuB,KAAKC,OAASjC,KAAKP,WAAaA,GAAc,IAOxEjB,gBAAgBc,QACTS,qBAAuBC,KAAKhB,aAAe,qBAC5CM,GAAaA,EAAY,EAAI,KAAO,MAAQU,KAAKT,qBAAuBS,KAAKrB,WAAL,kBACvEsF"}